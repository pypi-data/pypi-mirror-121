# generated by datamodel-codegen:
#   filename:  openapi.yaml

from __future__ import annotations

from datetime import date
from enum import Enum
from typing import List, Optional

from pydantic import Field

from cognite.well_model.base_model import WellsBaseModel


class DoubleWithUnit(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    value: float
    unit: str = Field(..., example="meter")


class StringItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[str]


class DateRange(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    min: Optional[date] = None
    max: Optional[date] = None


class DistanceUnitEnum(Enum):
    meter = "meter"
    foot = "foot"
    inch = "inch"
    yard = "yard"


class AngleUnitEnum(Enum):
    degree = "degree"
    radian = "radian"


class WeightUnitEnum(Enum):
    kilogram = "kilogram"
    pound = "pound"


class DurationUnitEnum(Enum):
    millisecond = "millisecond"
    second = "second"
    minute = "minute"
    hour = "hour"
    day = "day"


class DurationRange(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    unit: DurationUnitEnum
    min: Optional[float] = None
    max: Optional[float] = None


class Identifier(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matching_id: Optional[str] = Field(None, alias="matchingId")
    asset_external_id: Optional[str] = Field(None, alias="assetExternalId")


class IdentifierItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Identifier] = Field(..., max_items=1000, min_items=1)
    ignore_unknown_ids: Optional[bool] = Field(None, alias="ignoreUnknownIds")


class Item(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str


class NameItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Item]


class WellMergeRules(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: List[str]
    description: List[str]
    country: List[str]
    quadrant: List[str]
    region: List[str]
    block: List[str]
    field: List[str]
    operator: List[str]
    spud_date: List[str] = Field(..., alias="spudDate")
    license: List[str]
    well_type: List[str] = Field(..., alias="wellType")
    water_depth: List[str] = Field(..., alias="waterDepth")
    wellhead: List[str]


class Wellhead(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    x: float = Field(..., example=1)
    y: float = Field(..., example=1)
    crs: str = Field(..., example="Example")


class WellboreMergeRules(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: List[str]
    description: List[str]
    datum: List[str]


class SpudDateLimits(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    min: Optional[date] = None
    max: Optional[date] = None


class WaterDepthLimits(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    min: Optional[DoubleWithUnit] = None
    max: Optional[DoubleWithUnit] = None


class ContainsAllOrAny(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    contains_all: Optional[List[str]] = Field(None, alias="containsAll", description="match on all of the strings")
    contains_any: Optional[List[str]] = Field(None, alias="containsAny", description="match on any of the strings")


class ContainsAllOrAnyInt(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    contains_all: Optional[List[int]] = Field(None, alias="containsAll", description="match on all of the strings")
    contains_any: Optional[List[int]] = Field(None, alias="containsAny", description="match on any of the strings")


class MeasurementType(Enum):
    gamma_ray = "gammaRay"
    caliper = "caliper"
    density = "density"
    geomechanics = "geomechanics"
    ppfg = "ppfg"
    resistivity_deep = "resistivityDeep"
    resistivity_medium = "resistivityMedium"
    neutron = "neutron"
    fit = "fit"
    lot = "lot"
    acoustics = "acoustics"
    borehole_properties = "boreholeProperties"
    drilling_parameters = "drillingParameters"
    flag = "flag"
    fluid_properties = "fluidProperties"
    geophysical_synthetics = "geophysicalSynthetics"
    mud_logs = "mudLogs"
    nuclear_magnetc_resonance = "nuclearMagnetcResonance"
    permeability = "permeability"
    petrophysical_parameters = "petrophysicalParameters"
    photoelectric_factor = "photoelectricFactor"
    porosity = "porosity"
    pressure = "pressure"
    reference = "reference"
    resistivity = "resistivity"
    salinity = "salinity"
    saturation = "saturation"
    temperature = "temperature"
    volume_fraction = "volumeFraction"


class Item1(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    type: Optional[MeasurementType] = None


class MeasurementTypeItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Item1]


class TimeMeasurementColumn(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    timeseries_external_id: str = Field(
        ...,
        alias="timeseriesExternalId",
        description="The CDF external id of the timeseries containing the measurement data",
    )
    unit: str
    measurement_type: MeasurementType = Field(..., alias="measurementType")


class TimeMeasurementFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measurement_types: Optional[List[MeasurementType]] = Field(None, alias="measurementTypes")
    wellbore_ids: Optional[List[Identifier]] = Field(None, alias="wellboreIds")


class TrajectoryIngestionRow(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measured_depth: float = Field(..., alias="measuredDepth")
    inclination: float
    azimuth: float
    dogleg_severity: Optional[float] = Field(None, alias="doglegSeverity")


class TrajectoryFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_ids: Optional[List[Identifier]] = Field(None, alias="wellboreIds")


class TrajectoryFilterRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[TrajectoryFilter] = None
    limit: Optional[int] = Field(
        None,
        description="Maximum number of rows returned in one request. If there is more data beyond this limit, a cursor will be returned to enable further fetching of data.",
        ge=1.0,
        le=1000.0,
    )
    cursor: Optional[str] = Field(
        None,
        description="Cursor for pagination returned from a previous request. Apart from cursor and limit, the rest of the request object must be the same as for the original request.",
    )


class DistanceRange(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    unit: DistanceUnitEnum
    min: Optional[float] = None
    max: Optional[float] = None


class AngleRange(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    unit: AngleUnitEnum
    min: Optional[float] = None
    max: Optional[float] = None


class TrajectoryDataRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    sequence_external_id: str = Field(..., alias="sequenceExternalId")
    measured_depth: Optional[DistanceRange] = Field(None, alias="measuredDepth")
    true_vertical_depth: Optional[DistanceRange] = Field(None, alias="trueVerticalDepth")


class TrajectoryDataRow(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    true_vertical_depth: float = Field(..., alias="trueVerticalDepth")
    measured_depth: float = Field(..., alias="measuredDepth")
    northing: float
    easting: float
    azimuth: float
    inclination: float
    dogleg_severity: Optional[float] = Field(None, alias="doglegSeverity")


class TrajectoryDataRequestItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[TrajectoryDataRequest]


class CasingAssembly(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    min_inside_diameter: DoubleWithUnit = Field(..., alias="minInsideDiameter")
    min_outside_diameter: DoubleWithUnit = Field(..., alias="minOutsideDiameter")
    max_outside_diameter: DoubleWithUnit = Field(..., alias="maxOutsideDiameter")
    original_measured_depth_top: DoubleWithUnit = Field(..., alias="originalMeasuredDepthTop")
    original_measured_depth_base: DoubleWithUnit = Field(..., alias="originalMeasuredDepthBase")
    type: Optional[str] = None
    report_description: Optional[str] = Field(None, alias="reportDescription")


class CasingFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_ids: Optional[List[Identifier]] = Field(None, alias="wellboreIds")


class CasingFilterRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[CasingFilter] = None
    limit: Optional[int] = Field(
        None,
        description="Maximum number of rows returned in one request. If there is more data beyond this limit, a cursor will be returned to enable further fetching of data.",
        ge=1.0,
        le=1000.0,
    )
    cursor: Optional[str] = Field(
        None,
        description="Cursor for pagination returned from a previous request. Apart from cursor and limit, the rest of the request object must be the same as for the original request.",
    )


class WellSearch(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    query: str = Field(..., description="Fuzzy search name and description")


class WellTrajectoryFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    max_measured_depth: Optional[DistanceRange] = Field(None, alias="maxMeasuredDepth")
    max_true_vertical_depth: Optional[DistanceRange] = Field(None, alias="maxTrueVerticalDepth")
    max_inclination: Optional[AngleRange] = Field(None, alias="maxInclination")


class PolygonFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    geometry: str = Field(..., example="POINT (1.42 1.35)")
    crs: str = Field(..., example="EPSG:4326")
    geometry_type: Optional[str] = Field(None, alias="geometryType", example="WKT")


class ContainsAllOrAnyMeasurementType(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    contains_all: Optional[List[MeasurementType]] = Field(None, alias="containsAll")
    contains_any: Optional[List[MeasurementType]] = Field(None, alias="containsAny")


class DepthMeasurementDataRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    sequence_external_id: str = Field(..., alias="sequenceExternalId")
    measured_depth: Optional[DistanceRange] = Field(None, alias="measuredDepth")
    measurement_types: Optional[List[MeasurementType]] = Field(None, alias="measurementTypes")


class DepthMeasurementFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measurement_types: Optional[List[MeasurementType]] = Field(None, alias="measurementTypes")
    wellbore_ids: Optional[List[Identifier]] = Field(None, alias="wellboreIds")


class DistanceUnit(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    unit: DistanceUnitEnum
    factor: Optional[float] = Field(1.0, example=1.0)


class DepthMeasurementRow(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    row_number: int = Field(..., alias="rowNumber", description="The row number for this row", example=1, ge=0.0)
    measured_depth: float = Field(..., alias="measuredDepth")
    values: List = Field(
        ...,
        description="List of values in order defined in the columns field (Number of items must match. Null is accepted for missing values. String values must be no longer than 256 characters)",
        max_items=200,
        min_items=1,
    )


class DepthMeasurementValueTypeEnum(Enum):
    string = "string"
    double = "double"
    long = "long"


class AssetSource(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    asset_external_id: str = Field(..., alias="assetExternalId")
    source_name: str = Field(..., alias="sourceName", example="EDM")


class EventSource(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    event_external_id: str = Field(..., alias="eventExternalId")
    source_name: str = Field(..., alias="sourceName")


class SequenceSource(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    sequence_external_id: str = Field(..., alias="sequenceExternalId")
    source_name: str = Field(..., alias="sourceName", example="EDM")


class Error(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    code: int
    message: str


class ErrorResponse(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    error: Error


class Asset(WellsBaseModel):
    pass

    class Config:
        allow_population_by_field_name = True


class Source(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str = Field(..., example="EDM")
    description: Optional[str] = None


class Datum(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    elevation: DoubleWithUnit
    reference: str = Field(..., example="KB")


class WellIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matching_id: Optional[str] = Field(None, alias="matchingId")
    name: str
    description: Optional[str] = Field(
        None, description="additional description for the data", example="extracted from EDM"
    )
    country: Optional[str] = Field(None, example="Norway")
    quadrant: Optional[str] = Field(None, example="25")
    region: Optional[str] = None
    spud_date: Optional[date] = Field(None, alias="spudDate")
    block: Optional[str] = Field(None, example="25/5")
    field: Optional[str] = Field(None, example="Example")
    operator: Optional[str] = Field(None, example="Op1")
    well_type: Optional[str] = Field(None, alias="wellType", description='For example "exploration" or "development"')
    license: Optional[str] = Field(None, description="Well license")
    water_depth: Optional[DoubleWithUnit] = Field(None, alias="waterDepth")
    wellhead: Optional[Wellhead] = None
    source: AssetSource


class DeleteWells(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[AssetSource]


class FieldSources(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: Optional[AssetSource] = None
    description: Optional[AssetSource] = None
    country: Optional[AssetSource] = None
    quadrant: Optional[AssetSource] = None
    spud_date: Optional[AssetSource] = Field(None, alias="spudDate")
    block: Optional[AssetSource] = None
    field: Optional[AssetSource] = None
    operator: Optional[AssetSource] = None
    well_type: Optional[AssetSource] = Field(None, alias="wellType")
    license: Optional[AssetSource] = None
    water_depth: Optional[AssetSource] = Field(None, alias="waterDepth")
    wellhead: Optional[AssetSource] = None


class IncompleteWell(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matching_id: str = Field(..., alias="matchingId")
    sources: List[AssetSource]
    missing: List[str]


class IncompleteWellItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[IncompleteWell]
    next_cursor: Optional[str] = Field(None, alias="nextCursor")


class Wellbore(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matching_id: str = Field(..., alias="matchingId")
    name: str
    description: Optional[str] = None
    well_matching_id: str = Field(..., alias="wellMatchingId")
    parent_wellbore_matching_id: Optional[str] = Field(
        None, alias="parentWellboreMatchingId", description="Parent wellbore if it exists"
    )
    sources: List[AssetSource]
    datum: Optional[Datum] = None


class WellboreIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matching_id: Optional[str] = Field(None, alias="matchingId")
    name: str
    description: Optional[str] = None
    well_asset_external_id: str = Field(
        ..., alias="wellAssetExternalId", description="The CDF assetExternalId of the well parent of this wellbore"
    )
    parent_wellbore_asset_external_id: Optional[str] = Field(
        None,
        alias="parentWellboreAssetExternalId",
        description="If this wellbore is below another wellbore, add the parent wellbore's CDF assetExternalId here",
    )
    source: AssetSource
    datum: Optional[Datum] = None


class WellboreItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Wellbore]


class FieldSources1(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: Optional[AssetSource] = None
    description: Optional[AssetSource] = None
    datum: Optional[AssetSource] = None


class WellboreMergeDetails(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore: Wellbore
    field_sources: FieldSources1 = Field(..., alias="fieldSources")


class WellboreMergeDetailItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[WellboreMergeDetails]


class IncompleteWellbore(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matching_id: str = Field(..., alias="matchingId")
    sources: List[AssetSource]
    missing: List[str]


class IncompleteWellboreItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[IncompleteWellbore]
    next_cursor: Optional[str] = Field(None, alias="nextCursor")


class Npt(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ..., alias="wellboreAssetExternalId", description="The CDF asset external id to the connected wellbore."
    )
    npt_code: Optional[str] = Field(
        None, alias="nptCode", description="The NPT code to identify event.", example="ijiefe3:3463:npt"
    )
    npt_code_detail: Optional[str] = Field(
        None, alias="nptCodeDetail", description="A written explanation of an NPT event.", example="leak:242"
    )
    npt_level: Optional[str] = Field(
        None, alias="nptLevel", description="defines the level of non-productive time for the activity.", example="0"
    )
    source: EventSource
    description: Optional[str] = Field(
        None, description="Textual description of the event.", example="factual description of event"
    )
    start_time: int = Field(
        ...,
        alias="startTime",
        description="epoch time stamp in milliseconds for when the NPT event started.",
        example=1,
    )
    end_time: int = Field(
        ..., alias="endTime", description="epoch time stamp in milliseconds for when the NPT event ended.", example=1
    )
    measured_depth: Optional[DoubleWithUnit] = Field(None, alias="measuredDepth")
    duration: float = Field(..., description="Duration (hours) of the NPT event..", example=6.5)
    root_cause: Optional[str] = Field(
        None,
        alias="rootCause",
        description="Textual description of what caused the NPT event.",
        example="Leakage in pipe",
    )
    location: Optional[str] = Field(
        None, description="Location of NPT event.", example="location where failure event took place"
    )
    subtype: Optional[str] = Field(None, description="subtype of NPT event.", example="some subtype")


class NptIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="The CDF asset external id of the wellbore where the event happened.\nThe asset must have been ingested as a wellbore with the same source\nas this NPT event.\n",
    )
    npt_code: Optional[str] = Field(
        None, alias="nptCode", description="The NPT code to identify event.", example="ijiefe3:3463:npt"
    )
    npt_code_detail: Optional[str] = Field(
        None, alias="nptCodeDetail", description="A written explanation of an NPT event.", example="leak:242"
    )
    npt_level: Optional[str] = Field(
        None, alias="nptLevel", description="defines the level of non-productive time for the activity.", example="0"
    )
    source: EventSource
    description: Optional[str] = Field(
        None, description="Textual description of the event.", example="factual description of event"
    )
    start_time: int = Field(
        ..., alias="startTime", description="epoch time stamp in milliseconds for when the NPT event started."
    )
    end_time: int = Field(
        ..., alias="endTime", description="epoch time stamp in milliseconds for when the NPT event ended."
    )
    measured_depth: Optional[DoubleWithUnit] = Field(None, alias="measuredDepth")
    root_cause: Optional[str] = Field(
        None,
        alias="rootCause",
        description="Textual description of what caused the NPT event.",
        example="Leakage in pipe",
    )
    location: Optional[str] = Field(
        None, description="Location of NPT event.", example="location where failure event took place"
    )
    subtype: Optional[str] = Field(None, description="subtype of NPT event.")


class NptIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[NptIngestion]


class NptItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Npt]
    next_cursor: Optional[str] = Field(None, alias="nextCursor")


class NptFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measured_depth: Optional[DistanceRange] = Field(None, alias="measuredDepth")
    duration: Optional[DurationRange] = None
    npt_codes: Optional[List[str]] = Field(None, alias="nptCodes", description="match on any of the strings")
    npt_code_details: Optional[List[str]] = Field(
        None, alias="nptCodeDetails", description="match on any of the strings"
    )
    wellbore_ids: Optional[List[Identifier]] = Field(None, alias="wellboreIds")


class NptFilterRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[NptFilter] = None
    limit: Optional[int] = Field(
        None,
        description="Maximum number of rows returned in one request. If there is more data beyond this limit, a cursor will be returned to enable further fetching of data.",
        ge=1.0,
        le=1000.0,
    )
    cursor: Optional[str] = Field(
        None,
        description="Cursor for pagination returned from a previous request. Apart from cursor and limit, the rest of the request object must be the same as for the original request.",
    )


class WellNptFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measured_depth: Optional[DistanceRange] = Field(None, alias="measuredDepth")
    duration: Optional[DurationRange] = None
    npt_codes: Optional[ContainsAllOrAny] = Field(None, alias="nptCodes")
    npt_code_details: Optional[ContainsAllOrAny] = Field(None, alias="nptCodeDetails")


class Nds(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ..., alias="wellboreAssetExternalId", description="The CDF asset external id to the connected wellbore."
    )
    source: EventSource = Field(..., description="The source of this event.")
    description: Optional[str] = Field(
        None, description="Textual description of the event.", example="REAM OUT TIGHT HOLE"
    )
    hole_diameter: Optional[DoubleWithUnit] = Field(None, alias="holeDiameter")
    hole_start: DoubleWithUnit = Field(..., alias="holeStart")
    hole_end: DoubleWithUnit = Field(..., alias="holeEnd")
    risk_type: Optional[str] = Field(None, alias="riskType", description="Type of NDS risk.", example="some risk type")
    subtype: Optional[str] = Field(None, description="subtype of NDS risk.", example="some subtype")
    severity: int = Field(..., description="severity of NDS event", example=1)
    probability: int = Field(..., description="NDS event probability, between 0-5")


class NdsItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Nds]
    next_cursor: Optional[str] = Field(None, alias="nextCursor")


class NdsIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="The CDF asset external id of the wellbore where the event happened.\nThe asset must have been ingested as a wellbore with the same source\nas this NDS event.\n",
    )
    source: EventSource
    description: Optional[str] = Field(
        None, description="Textual description of the event.", example="REAM OUT TIGHT HOLE"
    )
    hole_diameter: Optional[DoubleWithUnit] = Field(None, alias="holeDiameter")
    hole_start: DoubleWithUnit = Field(..., alias="holeStart")
    hole_end: DoubleWithUnit = Field(..., alias="holeEnd")
    severity: int = Field(..., description="severity of NDS event", example=1)
    risk_type: Optional[str] = Field(None, alias="riskType", description="Type of NDS risk.", example="some risk type")
    subtype: Optional[str] = Field(None, description="subtype of NDS risk.", example="some subtype")
    probability: int = Field(..., description="NDS event probability, between 0-5")


class NdsIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[NdsIngestion]
    next_cursor: Optional[str] = Field(None, alias="nextCursor")


class NdsFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    hole_start: Optional[DistanceRange] = Field(None, alias="holeStart")
    hole_end: Optional[DistanceRange] = Field(None, alias="holeEnd")
    probabilities: Optional[List[int]] = None
    severities: Optional[List[int]] = None
    wellbore_ids: Optional[List[Identifier]] = Field(None, alias="wellboreIds")


class NdsFilterRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[NdsFilter] = None
    limit: Optional[int] = Field(
        None,
        description="Maximum number of rows returned in one request. If there is more data beyond this limit, a cursor will be returned to enable further fetching of data.",
        ge=1.0,
        le=1000.0,
    )
    cursor: Optional[str] = Field(
        None,
        description="Cursor for pagination returned from a previous request. Apart from cursor and limit, the rest of the request object must be the same as for the original request.",
    )


class WellNdsFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    severities: Optional[ContainsAllOrAnyInt] = None
    probabilities: Optional[ContainsAllOrAnyInt] = None
    risk_types: Optional[ContainsAllOrAny] = Field(None, alias="riskTypes")


class MeasuredDepthColumn(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    column_external_id: str = Field(
        ..., alias="columnExternalId", description="External id of the sequence column", example="MD"
    )
    unit: DistanceUnit


class DepthMeasurementColumn(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measurement_type: MeasurementType = Field(..., alias="measurementType")
    column_external_id: str = Field(
        ..., alias="columnExternalId", description="External id of the sequence column", example="GAMMA_RAY"
    )
    unit: str = Field(..., description="Unit for the measurement type", example="Roentgen")


class TimeMeasurement(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str
    source_name: str = Field(..., alias="sourceName")
    external_id: str = Field(..., alias="externalId")
    description: Optional[str] = None
    wellbore_asset_external_id: str = Field(..., alias="wellboreAssetExternalId")
    columns: List[TimeMeasurementColumn]


class TimeMeasurementItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[TimeMeasurement]
    next_cursor: Optional[str] = Field(None, alias="nextCursor")


class TimeMeasurementFilterRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[TimeMeasurementFilter] = None
    limit: Optional[int] = Field(
        None,
        description="Maximum number of rows returned in one request. If there is more data beyond this limit, a cursor will be returned to enable further fetching of data.",
        ge=1.0,
        le=1000.0,
    )
    cursor: Optional[str] = Field(
        None,
        description="Cursor for pagination returned from a previous request. Apart from cursor and limit, the rest of the request object must be the same as for the original request.",
    )


class Trajectory(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ..., alias="wellboreAssetExternalId", description="The CDF asset external id to the connected wellbore."
    )
    type: Optional[str] = None
    source: SequenceSource
    is_definitive: bool = Field(..., alias="isDefinitive")


class TrajectoryItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Trajectory]
    next_cursor: Optional[str] = Field(None, alias="nextCursor")


class TrajectoryIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="The CDF asset external id of the wellbore where the event happened.\nThe asset must have been ingested as a wellbore with the same source\nas this NPT event.\n",
    )
    source: SequenceSource
    type: Optional[str] = None
    measured_depth_unit: DistanceUnitEnum = Field(..., alias="measuredDepthUnit")
    inclination_unit: AngleUnitEnum = Field(..., alias="inclinationUnit")
    azimuth_unit: AngleUnitEnum = Field(..., alias="azimuthUnit")
    is_definitive: bool = Field(..., alias="isDefinitive")
    rows: List[TrajectoryIngestionRow]


class TrajectoryData(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(..., alias="wellboreAssetExternalId")
    source: SequenceSource
    type: Optional[str] = None
    measured_depth_unit: DistanceUnitEnum = Field(..., alias="measuredDepthUnit")
    inclination_unit: AngleUnitEnum = Field(..., alias="inclinationUnit")
    azimuth_unit: AngleUnitEnum = Field(..., alias="azimuthUnit")
    rows: List[TrajectoryDataRow]


class TrajectoryDataItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[TrajectoryData]


class TrajectoryInterpolationRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_id: Identifier = Field(
        ..., alias="wellboreId", description="Interpolate the definitive trajectory of this wellbore"
    )
    measured_depths: List[float] = Field(..., alias="measuredDepths")
    measured_depth_unit: DistanceUnit = Field(..., alias="measuredDepthUnit")
    true_vertical_depth_unit: Optional[DistanceUnit] = Field(None, alias="trueVerticalDepthUnit")


class TrueVerticalDepths(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    true_vertical_depths: List[float] = Field(..., alias="trueVerticalDepths")
    true_vertical_depth_unit: DistanceUnit = Field(..., alias="trueVerticalDepthUnit")
    sequence_source: SequenceSource = Field(..., alias="sequenceSource")
    wellbore_asset_external_id: str = Field(..., alias="wellboreAssetExternalId")


class CasingSchematic(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(..., alias="wellboreAssetExternalId")
    casing_assemblies: List[CasingAssembly] = Field(..., alias="casingAssemblies")
    source: SequenceSource
    phase: str


class TrajectoryFilterList(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[WellTrajectoryFilter] = None


class WellMeasurementFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measurement_types: Optional[ContainsAllOrAnyMeasurementType] = Field(None, alias="measurementTypes")
    measured_depth: Optional[DistanceRange] = Field(None, alias="measuredDepth")


class WellTimeMeasurementFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measurement_types: Optional[ContainsAllOrAnyMeasurementType] = Field(None, alias="measurementTypes")


class DepthMeasurementDataRequestItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[DepthMeasurementDataRequest]


class DepthMeasurementFilterRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[DepthMeasurementFilter] = None
    limit: Optional[int] = Field(
        None,
        description="Maximum number of rows returned in one request. If there is more data beyond this limit, a cursor will be returned to enable further fetching of data.",
        ge=1.0,
        le=1000.0,
    )
    cursor: Optional[str] = Field(
        None,
        description="Cursor for pagination returned from a previous request. Apart from cursor and limit, the rest of the request object must be the same as for the original request.",
    )


class DepthMeasurementDataColumn(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    external_id: str = Field(
        ...,
        alias="externalId",
        description="User provided column identifier (Unique for a given sequence)",
        example="DPS1",
    )
    name: Optional[str] = Field(None, description="Human readable name of the column", example="Depth sensor 1")
    measurement_type: MeasurementType = Field(..., alias="measurementType")
    unit: str = Field(..., description="Unit for the measurement type", example="meter")
    value_type: DepthMeasurementValueTypeEnum = Field(..., alias="valueType")


class SourceItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Source]


class Well(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matching_id: str = Field(..., alias="matchingId")
    name: str = Field(..., example="25/5-5")
    description: Optional[str] = Field(None, description="additional description for the data")
    country: Optional[str] = Field(None, example="Norway")
    quadrant: Optional[str] = Field(None, example="25")
    region: Optional[str] = None
    block: Optional[str] = Field(None, example="25/5")
    field: Optional[str] = None
    operator: Optional[str] = None
    spud_date: Optional[date] = Field(None, alias="spudDate")
    well_type: Optional[str] = Field(None, alias="wellType", description='For example "exploration" or "development"')
    license: Optional[str] = Field(None, description="Well license")
    wellhead: Wellhead
    water_depth: DoubleWithUnit = Field(..., alias="waterDepth")
    sources: List[AssetSource] = Field(
        ...,
        description="List of source systems that are associated to this well (user may drill down further to explore metadata for each source by calling well/{id}/source/{sourcename}",
    )
    wellbores: Optional[List[Wellbore]] = Field(None, description="List of wellbores associated to this well")


class WellItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Well]
    next_cursor: Optional[str] = Field(None, alias="nextCursor")


class WellIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[WellIngestion]


class WellMergeDetails(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    well: Well
    field_sources: FieldSources = Field(..., alias="fieldSources")


class WellMergeDetailItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[WellMergeDetails]


class WellboreIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[WellboreIngestion]


class DepthMeasurement(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="The CDF asset external id of the wellbore.\nThe asset must have been ingested as a wellbore with the same source\nas this NPT event.\n",
    )
    source: SequenceSource
    measured_depth: MeasuredDepthColumn = Field(..., alias="measuredDepth")
    columns: List[DepthMeasurementColumn]


class DepthMeasurementItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[DepthMeasurement]
    next_cursor: Optional[str] = Field(None, alias="nextCursor")


class TrajectoryIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[TrajectoryIngestion]


class TrajectoryInterpolationRequestItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[TrajectoryInterpolationRequest]
    ignore_missing_trajectories: Optional[bool] = Field(None, alias="ignoreMissingTrajectories")


class TrajectoryInterpolationItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[TrueVerticalDepths]


class CasingIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[CasingSchematic]


class CasingItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[CasingSchematic]
    next_cursor: Optional[str] = Field(None, alias="nextCursor")


class WellFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    quadrants: Optional[List[str]] = Field(None, example=["24", "25", "34"])
    regions: Optional[List[str]] = Field(None, example=["Gulf of mexico", "North Sea"])
    blocks: Optional[List[str]] = Field(None, example=["24/6", "25/7", "34/1"])
    fields: Optional[List[str]] = Field(None, example=["Gullfaks", "Alvheim"])
    operators: Optional[List[str]] = Field(None, example=["op1", "op2"])
    well_types: Optional[List[str]] = Field(None, alias="wellTypes", example=["exploration", "development"])
    licenses: Optional[List[str]] = None
    sources: Optional[List[str]] = Field(None, example=["EDM", "Sitecom"])
    water_depth: Optional[DistanceRange] = Field(None, alias="waterDepth")
    spud_date: Optional[DateRange] = Field(None, alias="spudDate")
    polygon: Optional[PolygonFilter] = None
    trajectories: Optional[WellTrajectoryFilter] = None
    measurements: Optional[WellMeasurementFilter] = None
    time_measurements: Optional[WellTimeMeasurementFilter] = Field(None, alias="timeMeasurements")
    npt: Optional[WellNptFilter] = None
    nds: Optional[WellNdsFilter] = None


class WellFilterRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[WellFilter] = None
    search: Optional[WellSearch] = None
    output_crs: Optional[str] = Field(None, alias="outputCrs", example="EPSG:4326")
    limit: Optional[int] = Field(
        None,
        description="Maximum number of rows returned in one request. If there is more data beyond this limit, a cursor will be returned to enable further fetching of data.",
        ge=1.0,
        le=1000.0,
    )
    cursor: Optional[str] = Field(
        None,
        description="Cursor for pagination returned from a previous request. Apart from cursor and limit, the rest of the request object must be the same as for the original request.",
    )


class DepthMeasurementData(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    id: int
    source: SequenceSource
    measured_depth_unit: DistanceUnit = Field(..., alias="measuredDepthUnit")
    columns: List[DepthMeasurementDataColumn] = Field(..., description="Column information in order given by data")
    rows: List[DepthMeasurementRow] = Field(..., description="List of row information")
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="Cursor to get the next page of results (if available)."
    )


class DepthMeasurementDataItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[DepthMeasurementData]
