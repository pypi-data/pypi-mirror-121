# coding: utf-8

"""
    ARLAS Exploration API

    Explore the content of ARLAS collections  # noqa: E501

    OpenAPI spec version: 19.0.0
    Contact: contact@gisaia.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from arlas_api_python.api_client import ApiClient


class StacApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def describe_collection(self, collection_id, **kwargs):  # noqa: E501
        """Describe the feature collection with id `collectionId`  # noqa: E501

        A single Feature Collection for the given id `collectionId`. Request this endpoint to get a full list of metadata for the Feature Collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.describe_collection(collection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str collection_id: Local identifier of a collection (required)
        :return: Collection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.describe_collection_with_http_info(collection_id, **kwargs)  # noqa: E501
        else:
            (data) = self.describe_collection_with_http_info(collection_id, **kwargs)  # noqa: E501
            return data

    def describe_collection_with_http_info(self, collection_id, **kwargs):  # noqa: E501
        """Describe the feature collection with id `collectionId`  # noqa: E501

        A single Feature Collection for the given id `collectionId`. Request this endpoint to get a full list of metadata for the Feature Collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.describe_collection_with_http_info(collection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str collection_id: Local identifier of a collection (required)
        :return: Collection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['collection_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method describe_collection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'collection_id' is set
        if ('collection_id' not in params or
                params['collection_id'] is None):
            raise ValueError("Missing the required parameter `collection_id` when calling `describe_collection`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'collection_id' in params:
            path_params['collectionId'] = params['collection_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/stac/collections/{collectionId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Collection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_api(self, **kwargs):  # noqa: E501
        """OpenAPI  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_api(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_api_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_api_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_api_with_http_info(self, **kwargs):  # noqa: E501
        """OpenAPI  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_api" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.oai.openapi+json;version=3.0'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/stac/api', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_collections(self, **kwargs):  # noqa: E501
        """The feature collections in the dataset  # noqa: E501

        A body of Feature Collections that belong or are used together with additional links. Request may not return the full set of metadata per Feature Collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collections(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CollectionList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_collections_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_collections_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_collections_with_http_info(self, **kwargs):  # noqa: E501
        """The feature collections in the dataset  # noqa: E501

        A body of Feature Collections that belong or are used together with additional links. Request may not return the full set of metadata per Feature Collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collections_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CollectionList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_collections" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/stac/collections', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CollectionList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_conformance_declaration(self, **kwargs):  # noqa: E501
        """Conformance  # noqa: E501

        The URIs of all conformance classes supported by the server. To support \"generic\" clients that want to access multiple OGC API Features implementations - and not \"just\" a specific API / server, the server declares the conformance classes it implements and conforms to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_conformance_declaration(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ConformanceClasses
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_conformance_declaration_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_conformance_declaration_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_conformance_declaration_with_http_info(self, **kwargs):  # noqa: E501
        """Conformance  # noqa: E501

        The URIs of all conformance classes supported by the server. To support \"generic\" clients that want to access multiple OGC API Features implementations - and not \"just\" a specific API / server, the server declares the conformance classes it implements and conforms to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_conformance_declaration_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ConformanceClasses
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_conformance_declaration" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/stac/conformance', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConformanceClasses',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_feature(self, collection_id, feature_id, **kwargs):  # noqa: E501
        """Fetch a single feature  # noqa: E501

        Fetch the feature with id `featureId` in the feature collection with id `collectionId`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_feature(collection_id, feature_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str collection_id: Local identifier of a collection (required)
        :param str feature_id: Local identifier of a feature (required)
        :return: Item
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_feature_with_http_info(collection_id, feature_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_feature_with_http_info(collection_id, feature_id, **kwargs)  # noqa: E501
            return data

    def get_feature_with_http_info(self, collection_id, feature_id, **kwargs):  # noqa: E501
        """Fetch a single feature  # noqa: E501

        Fetch the feature with id `featureId` in the feature collection with id `collectionId`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_feature_with_http_info(collection_id, feature_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str collection_id: Local identifier of a collection (required)
        :param str feature_id: Local identifier of a feature (required)
        :return: Item
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['collection_id', 'feature_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_feature" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'collection_id' is set
        if ('collection_id' not in params or
                params['collection_id'] is None):
            raise ValueError("Missing the required parameter `collection_id` when calling `get_feature`")  # noqa: E501
        # verify the required parameter 'feature_id' is set
        if ('feature_id' not in params or
                params['feature_id'] is None):
            raise ValueError("Missing the required parameter `feature_id` when calling `get_feature`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'collection_id' in params:
            path_params['collectionId'] = params['collection_id']  # noqa: E501
        if 'feature_id' in params:
            path_params['featureId'] = params['feature_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/stac/collections/{collectionId}/items/{featureId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Item',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_features(self, collection_id, **kwargs):  # noqa: E501
        """Fetch features  # noqa: E501

        Fetch features of the feature collection with id `collectionId`. Every feature in a dataset belongs to a collection. A dataset may consist of multiple feature collections. A feature collection is often a collection of features of a similar type, based on a common schema.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_features(collection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str collection_id: Local identifier of a collection (required)
        :param str limit: The optional limit parameter limits the number of items that are presented in the response document. Only items are counted that are on the first level of the collection in the response document. Nested objects contained within the explicitly requested items shall not be counted. Minimum &#x3D; 1. Maximum &#x3D; 10000. Default &#x3D; 10.
        :param str bbox: Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):   * Lower left corner, coordinate axis 1   * Lower left corner, coordinate axis 2   * Minimum value, coordinate axis 3 (optional)   * Upper right corner, coordinate axis 1   * Upper right corner, coordinate axis 2   * Maximum value, coordinate axis 3 (optional)  The coordinate reference system of the values is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84). For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge). If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box. If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.
        :param str _datetime: Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots.  Examples:   * A date-time: \"2018-02-12T23:20:50Z\"   * A closed interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\"   * Open intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected. If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
        :param str sortby: **Optional Extension:** Sort  An array of property names, prefixed by either \"+\" for ascending or \"-\" for descending. If no prefix is provided, \"+\" is assumed.
        :param int _from: From index to start the search from. Defaults to 0.
        :param str after: List of values of fields present in sort param that are used to search after.    > **What it does**: Retrieve the data placed after the pointed element, given the provided order (sort).   > __**Restriction 1**__: **after** param works only combined with **sort** param.   > __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.   > **Note 1**: *{value1}` and `{value2}` are the values of `{field1}` and `{field2}` in the last hit returned in the previous search   > **Note 2**: The order of fields and values matters. *{value1},{value2}* must be in the same order of *{field1},{field2}* in **sort** param   > **Note 3**:  The last field `{fieldN}` must be the id field specified in the collection **collection.params.idPath** (returned as **md.id**) and `{valueN}` its corresponding value.   > __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*. Gets the following hits of the previous search that stopped at date *01/02/2019* and id *abcd1234*.   > __**Restriction 2**__: **from** param must be set to 0 or kept unset   
        :param str before: Same idea that after param, but to retrieve the data placed before the pointed element, given the provided order (sort).
        :return: StacFeatureCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_features_with_http_info(collection_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_features_with_http_info(collection_id, **kwargs)  # noqa: E501
            return data

    def get_features_with_http_info(self, collection_id, **kwargs):  # noqa: E501
        """Fetch features  # noqa: E501

        Fetch features of the feature collection with id `collectionId`. Every feature in a dataset belongs to a collection. A dataset may consist of multiple feature collections. A feature collection is often a collection of features of a similar type, based on a common schema.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_features_with_http_info(collection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str collection_id: Local identifier of a collection (required)
        :param str limit: The optional limit parameter limits the number of items that are presented in the response document. Only items are counted that are on the first level of the collection in the response document. Nested objects contained within the explicitly requested items shall not be counted. Minimum &#x3D; 1. Maximum &#x3D; 10000. Default &#x3D; 10.
        :param str bbox: Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):   * Lower left corner, coordinate axis 1   * Lower left corner, coordinate axis 2   * Minimum value, coordinate axis 3 (optional)   * Upper right corner, coordinate axis 1   * Upper right corner, coordinate axis 2   * Maximum value, coordinate axis 3 (optional)  The coordinate reference system of the values is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84). For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge). If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box. If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.
        :param str _datetime: Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots.  Examples:   * A date-time: \"2018-02-12T23:20:50Z\"   * A closed interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\"   * Open intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected. If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
        :param str sortby: **Optional Extension:** Sort  An array of property names, prefixed by either \"+\" for ascending or \"-\" for descending. If no prefix is provided, \"+\" is assumed.
        :param int _from: From index to start the search from. Defaults to 0.
        :param str after: List of values of fields present in sort param that are used to search after.    > **What it does**: Retrieve the data placed after the pointed element, given the provided order (sort).   > __**Restriction 1**__: **after** param works only combined with **sort** param.   > __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.   > **Note 1**: *{value1}` and `{value2}` are the values of `{field1}` and `{field2}` in the last hit returned in the previous search   > **Note 2**: The order of fields and values matters. *{value1},{value2}* must be in the same order of *{field1},{field2}* in **sort** param   > **Note 3**:  The last field `{fieldN}` must be the id field specified in the collection **collection.params.idPath** (returned as **md.id**) and `{valueN}` its corresponding value.   > __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*. Gets the following hits of the previous search that stopped at date *01/02/2019* and id *abcd1234*.   > __**Restriction 2**__: **from** param must be set to 0 or kept unset   
        :param str before: Same idea that after param, but to retrieve the data placed before the pointed element, given the provided order (sort).
        :return: StacFeatureCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['collection_id', 'limit', 'bbox', '_datetime', 'sortby', '_from', 'after', 'before']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_features" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'collection_id' is set
        if ('collection_id' not in params or
                params['collection_id'] is None):
            raise ValueError("Missing the required parameter `collection_id` when calling `get_features`")  # noqa: E501

        if 'limit' in params and params['limit'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `get_features`, must be a value less than or equal to `10000`")  # noqa: E501
        if 'limit' in params and params['limit'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `get_features`, must be a value greater than or equal to `1`")  # noqa: E501
        if '_from' in params and params['_from'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `_from` when calling `get_features`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'collection_id' in params:
            path_params['collectionId'] = params['collection_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'bbox' in params:
            query_params.append(('bbox', params['bbox']))  # noqa: E501
        if '_datetime' in params:
            query_params.append(('datetime', params['_datetime']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'before' in params:
            query_params.append(('before', params['before']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/stac/collections/{collectionId}/items', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StacFeatureCollection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_item_search(self, **kwargs):  # noqa: E501
        """Search STAC items with simple filtering.  # noqa: E501

        Retrieve Items matching filters. Intended as a shorthand API for simple queries.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_item_search(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str bbox: Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):   * Lower left corner, coordinate axis 1   * Lower left corner, coordinate axis 2   * Minimum value, coordinate axis 3 (optional)   * Upper right corner, coordinate axis 1   * Upper right corner, coordinate axis 2   * Maximum value, coordinate axis 3 (optional)  The coordinate reference system of the values is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84). For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge). If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box. If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.  Example: The bounding box of the New Zealand Exclusive Economic Zone in WGS 84 (from 160.6°E to 170°W and from 55.95°S to 25.89°S) would be represented in JSON as &#x60;[160.6, -55.95, -170, -25.89]&#x60; and in a query as &#x60;bbox&#x3D;160.6,-55.95,-170,-25.89&#x60;.
        :param str intersects: The optional intersects parameter filters the result Items in the same way as bbox, only with a GeoJSON Geometry rather than a bbox.
        :param str _datetime: Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots.  Examples:   * A date-time: \"2018-02-12T23:20:50Z\"   * A closed interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\"   * Open intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected. If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
        :param str limit: The optional limit parameter limits the number of items that are presented in the response document. Only items are counted that are on the first level of the collection in the response document. Nested objects contained within the explicitly requested items shall not be counted.  Minimum &#x3D; 1. Maximum &#x3D; 10000. Default &#x3D; 10.
        :param list[str] ids: Array of Item ids to return.
        :param list[str] collections: Array of Collection IDs to include in the search for items. Only Item objects in one of the provided collections will be searched 
        :param str sortby: **Optional Extension:** Sort  An array of property names, prefixed by either \"+\" for ascending or \"-\" for descending. If no prefix is provided, \"+\" is assumed.
        :param int _from: From index to start the search from. Defaults to 0.
        :param str after: List of values of fields present in sort param that are used to search after.    > **What it does**: Retrieve the data placed after the pointed element, given the provided order (sort).   > __**Restriction 1**__: **after** param works only combined with **sort** param.   > __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.   > **Note 1**: *{value1}` and `{value2}` are the values of `{field1}` and `{field2}` in the last hit returned in the previous search   > **Note 2**: The order of fields and values matters. *{value1},{value2}* must be in the same order of *{field1},{field2}* in **sort** param   > **Note 3**:  The last field `{fieldN}` must be the id field specified in the collection **collection.params.idPath** (returned as **md.id**) and `{valueN}` its corresponding value.   > __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*. Gets the following hits of the previous search that stopped at date *01/02/2019* and id *abcd1234*.   > __**Restriction 2**__: **from** param must be set to 0 or kept unset   
        :param str before: Same idea that after param, but to retrieve the data placed before the pointed element, given the provided order (sort).
        :return: StacFeatureCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_item_search_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_item_search_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_item_search_with_http_info(self, **kwargs):  # noqa: E501
        """Search STAC items with simple filtering.  # noqa: E501

        Retrieve Items matching filters. Intended as a shorthand API for simple queries.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_item_search_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str bbox: Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):   * Lower left corner, coordinate axis 1   * Lower left corner, coordinate axis 2   * Minimum value, coordinate axis 3 (optional)   * Upper right corner, coordinate axis 1   * Upper right corner, coordinate axis 2   * Maximum value, coordinate axis 3 (optional)  The coordinate reference system of the values is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84). For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge). If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box. If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.  Example: The bounding box of the New Zealand Exclusive Economic Zone in WGS 84 (from 160.6°E to 170°W and from 55.95°S to 25.89°S) would be represented in JSON as &#x60;[160.6, -55.95, -170, -25.89]&#x60; and in a query as &#x60;bbox&#x3D;160.6,-55.95,-170,-25.89&#x60;.
        :param str intersects: The optional intersects parameter filters the result Items in the same way as bbox, only with a GeoJSON Geometry rather than a bbox.
        :param str _datetime: Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots.  Examples:   * A date-time: \"2018-02-12T23:20:50Z\"   * A closed interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\"   * Open intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected. If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
        :param str limit: The optional limit parameter limits the number of items that are presented in the response document. Only items are counted that are on the first level of the collection in the response document. Nested objects contained within the explicitly requested items shall not be counted.  Minimum &#x3D; 1. Maximum &#x3D; 10000. Default &#x3D; 10.
        :param list[str] ids: Array of Item ids to return.
        :param list[str] collections: Array of Collection IDs to include in the search for items. Only Item objects in one of the provided collections will be searched 
        :param str sortby: **Optional Extension:** Sort  An array of property names, prefixed by either \"+\" for ascending or \"-\" for descending. If no prefix is provided, \"+\" is assumed.
        :param int _from: From index to start the search from. Defaults to 0.
        :param str after: List of values of fields present in sort param that are used to search after.    > **What it does**: Retrieve the data placed after the pointed element, given the provided order (sort).   > __**Restriction 1**__: **after** param works only combined with **sort** param.   > __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.   > **Note 1**: *{value1}` and `{value2}` are the values of `{field1}` and `{field2}` in the last hit returned in the previous search   > **Note 2**: The order of fields and values matters. *{value1},{value2}* must be in the same order of *{field1},{field2}* in **sort** param   > **Note 3**:  The last field `{fieldN}` must be the id field specified in the collection **collection.params.idPath** (returned as **md.id**) and `{valueN}` its corresponding value.   > __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*. Gets the following hits of the previous search that stopped at date *01/02/2019* and id *abcd1234*.   > __**Restriction 2**__: **from** param must be set to 0 or kept unset   
        :param str before: Same idea that after param, but to retrieve the data placed before the pointed element, given the provided order (sort).
        :return: StacFeatureCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bbox', 'intersects', '_datetime', 'limit', 'ids', 'collections', 'sortby', '_from', 'after', 'before']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_item_search" % key
                )
            params[key] = val
        del params['kwargs']

        if 'limit' in params and params['limit'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `get_item_search`, must be a value less than or equal to `10000`")  # noqa: E501
        if 'limit' in params and params['limit'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `get_item_search`, must be a value greater than or equal to `1`")  # noqa: E501
        if '_from' in params and params['_from'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `_from` when calling `get_item_search`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'bbox' in params:
            query_params.append(('bbox', params['bbox']))  # noqa: E501
        if 'intersects' in params:
            query_params.append(('intersects', params['intersects']))  # noqa: E501
        if '_datetime' in params:
            query_params.append(('datetime', params['_datetime']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'ids' in params:
            query_params.append(('ids', params['ids']))  # noqa: E501
            collection_formats['ids'] = 'multi'  # noqa: E501
        if 'collections' in params:
            query_params.append(('collections', params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'before' in params:
            query_params.append(('before', params['before']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'text/html', 'application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/stac/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StacFeatureCollection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_landing_page(self, **kwargs):  # noqa: E501
        """Landing page  # noqa: E501

        Returns the root STAC Catalog or STAC Collection that is the entry point for users to browse with STAC Browser or for search engines to crawl. This can either return a single STAC Collection or more commonly a STAC catalog. The landing page provides links to the API definition (link relations `service-desc` and `service-doc`) and the STAC records such as collections/catalogs (link relation `child`) or items (link relation `item`). Extensions may add additional links with new relation types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_landing_page(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: LandingPage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_landing_page_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_landing_page_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_landing_page_with_http_info(self, **kwargs):  # noqa: E501
        """Landing page  # noqa: E501

        Returns the root STAC Catalog or STAC Collection that is the entry point for users to browse with STAC Browser or for search engines to crawl. This can either return a single STAC Collection or more commonly a STAC catalog. The landing page provides links to the API definition (link relations `service-desc` and `service-doc`) and the STAC records such as collections/catalogs (link relation `child`) or items (link relation `item`). Extensions may add additional links with new relation types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_landing_page_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: LandingPage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_landing_page" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/stac', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LandingPage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_item_search(self, **kwargs):  # noqa: E501
        """Search STAC items with full-featured filtering.  # noqa: E501

        Retrieve items matching filters. Intended as the standard, full-featured query API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_item_search(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SearchBody body:
        :return: StacFeatureCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_item_search_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_item_search_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_item_search_with_http_info(self, **kwargs):  # noqa: E501
        """Search STAC items with full-featured filtering.  # noqa: E501

        Retrieve items matching filters. Intended as the standard, full-featured query API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_item_search_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SearchBody body:
        :return: StacFeatureCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_item_search" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'text/html', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/stac/search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StacFeatureCollection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
