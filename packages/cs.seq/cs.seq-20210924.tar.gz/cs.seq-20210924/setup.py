#!/usr/bin/env python
from setuptools import setup
setup(
  name = 'cs.seq',
  author = 'Cameron Simpson',
  author_email = 'cs@cskk.id.au',
  version = '20210924',
  url = 'https://bitbucket.org/cameron_simpson/css/commits/all',
  description =
    'Stuff to do with counters, sequences and iterables.',
  long_description =
    ('Stuff to do with counters, sequences and iterables.\n'    
 '\n'    
 '*Latest release 20210924*:\n'    
 'New greedy(iterable) or @greedy(generator_function) to let generators '    
 'precompute.\n'    
 '\n'    
 'Note that any function accepting an iterable\n'    
 'will consume some or all of the derived iterator\n'    
 'in the course of its function.\n'    
 '\n'    
 '## Function `common_prefix_length(*seqs)`\n'    
 '\n'    
 'Return the length of the common prefix of sequences `seqs`.\n'    
 '\n'    
 '## Function `common_suffix_length(*seqs)`\n'    
 '\n'    
 'Return the length of the common suffix of sequences `seqs`.\n'    
 '\n'    
 '## Function `first(iterable)`\n'    
 '\n'    
 'Return the first item from an iterable; raise IndexError on empty '    
 'iterables.\n'    
 '\n'    
 '## Function `get0(iterable, default=None)`\n'    
 '\n'    
 'Return first element of an iterable, or the default.\n'    
 '\n'    
 '## Function `greedy(g=None, queue_depth=0)`\n'    
 '\n'    
 'A decorator or function for greedy computation of iterables.\n'    
 '\n'    
 'If `g` is omitted or callable\n'    
 'this is a decorator for a generator function\n'    
 'causing it to compute greedily,\n'    
 'capacity limited by `queue_depth`.\n'    
 '\n'    
 'If `g` is iterable\n'    
 'this function dispatches it in a `Thread` to compute greedily,\n'    
 'capacity limited by `queue_depth`.\n'    
 '\n'    
 'Example with an iterable:\n'    
 '\n'    
 '    for packet in greedy(parse_data_stream(stream)):\n'    
 '        ... process packet ...\n'    
 '\n'    
 'which does some readahead of the stream.\n'    
 '\n'    
 'Example as a function decorator:\n'    
 '\n'    
 '    @greedy\n'    
 '    def g(n):\n'    
 '        for item in range(n):\n'    
 '            yield n\n'    
 '\n'    
 'This can also be used directly on an existing iterable:\n'    
 '\n'    
 '    for item in greedy(range(n)):\n'    
 '        yield n\n'    
 '\n'    
 'Normally a generator runs on demand.\n'    
 'This function dispatches a `Thread` to run the iterable\n'    
 '(typically a generator)\n'    
 'putting yielded values to a queue\n'    
 'and returns a new generator yielding from the queue.\n'    
 '\n'    
 'The `queue_depth` parameter specifies the depth of the queue\n'    
 'and therefore how many values the original generator can compute\n'    
 "before blocking at the queue's capacity.\n"    
 '\n'    
 'The default `queue_depth` is `0` which creates a `Channel`\n'    
 'as the queue - a zero storage buffer - which lets the generator\n'    
 'compute only a single value ahead of time.\n'    
 '\n'    
 'A larger `queue_depth` allocates a `Queue` with that much storage\n'    
 'allowing the generator to compute as many as `queue_depth+1` values\n'    
 'ahead of time.\n'    
 '\n'    
 "Here's a comparison of the behaviour:\n"    
 '\n'    
 'Example without `@greedy`\n'    
 'where the "yield 1" step does not occur until after the "got 0":\n'    
 '\n'    
 '    >>> from time import sleep\n'    
 '    >>> def g():\n'    
 '    ...   for i in range(2):\n'    
 '    ...     print("yield", i)\n'    
 '    ...     yield i\n'    
 '    ...   print("g done")\n'    
 '    ...\n'    
 '    >>> G = g(); sleep(0.1)\n'    
 '    >>> for i in G:\n'    
 '    ...   print("got", i)\n'    
 '    ...   sleep(0.1)\n'    
 '    ...\n'    
 '    yield 0\n'    
 '    got 0\n'    
 '    yield 1\n'    
 '    got 1\n'    
 '    g done\n'    
 '\n'    
 'Example with `@greedy`\n'    
 'where the "yield 1" step computes before the "got 0":\n'    
 '\n'    
 '    >>> from time import sleep\n'    
 '    >>> @greedy\n'    
 '    ... def g():\n'    
 '    ...   for i in range(2):\n'    
 '    ...     print("yield", i)\n'    
 '    ...     yield i\n'    
 '    ...   print("g done")\n'    
 '    ...\n'    
 '    >>> G = g(); sleep(0.1)\n'    
 '    yield 0\n'    
 '    >>> for i in G:\n'    
 '    ...   print("got", repr(i))\n'    
 '    ...   sleep(0.1)\n'    
 '    ...\n'    
 '    yield 1\n'    
 '    got 0\n'    
 '    g done\n'    
 '    got 1\n'    
 '\n'    
 'Example with `@greedy(queue_depth=1)`\n'    
 'where the "yield 1" step computes before the "got 0":\n'    
 '\n'    
 '    >>> from cs.x import X\n'    
 '    >>> from time import sleep\n'    
 '    >>> @greedy\n'    
 '    ... def g():\n'    
 '    ...   for i in range(3):\n'    
 '    ...     X("Y")\n'    
 '    ...     print("yield", i)\n'    
 '    ...     yield i\n'    
 '    ...   print("g done")\n'    
 '    ...\n'    
 '    >>> G = g(); sleep(2)\n'    
 '    yield 0\n'    
 '    yield 1\n'    
 '    >>> for i in G:\n'    
 '    ...   print("got", repr(i))\n'    
 '    ...   sleep(0.1)\n'    
 '    ...\n'    
 '    yield 2\n'    
 '    got 0\n'    
 '    yield 3\n'    
 '    got 1\n'    
 '    g done\n'    
 '    got 2\n'    
 '\n'    
 '## Function `imerge(*iters, **kw)`\n'    
 '\n'    
 'Merge an iterable of ordered iterables in order.\n'    
 '\n'    
 'Parameters:\n'    
 '* `iters`: an iterable of iterators\n'    
 '* `reverse`: keyword parameter: if true, yield items in reverse order.\n'    
 '  This requires the iterables themselves to also be in\n'    
 '  reversed order.\n'    
 '\n'    
 'This function relies on the source iterables being ordered\n'    
 'and their elements being comparable, through slightly misordered\n'    
 'iterables (for example, as extracted from web server logs)\n'    
 'will produce only slightly misordered results, as the merging\n'    
 'is done on the basis of the front elements of each iterable.\n'    
 '\n'    
 '## Function `isordered(items, reverse=False, strict=False)`\n'    
 '\n'    
 'Test whether an iterable is ordered.\n'    
 'Note that the iterable is iterated, so this is a destructive\n'    
 'test for nonsequences.\n'    
 '\n'    
 '## Function `last(iterable)`\n'    
 '\n'    
 'Return the last item from an iterable; raise IndexError on empty iterables.\n'    
 '\n'    
 '## Function `onetomany(func)`\n'    
 '\n'    
 'A decorator for a method of a sequence to merge the results of\n'    
 'passing every element of the sequence to the function, expecting\n'    
 'multiple values back.\n'    
 '\n'    
 'Example:\n'    
 '\n'    
 '      class X(list):\n'    
 '            @onetomany\n'    
 '            def chars(self, item):\n'    
 '                  return item\n'    
 "      strs = X(['Abc', 'Def'])\n"    
 '      all_chars = X.chars()\n'    
 '\n'    
 '## Function `onetoone(func)`\n'    
 '\n'    
 'A decorator for a method of a sequence to merge the results of\n'    
 'passing every element of the sequence to the function, expecting a\n'    
 'single value back.\n'    
 '\n'    
 'Example:\n'    
 '\n'    
 '      class X(list):\n'    
 '            @onetoone\n'    
 '            def lower(self, item):\n'    
 '                  return item.lower()\n'    
 "      strs = X(['Abc', 'Def'])\n"    
 '      lower_strs = X.lower()\n'    
 '\n'    
 '## Class `Seq`\n'    
 '\n'    
 'A thread safe wrapper for itertools.count().\n'    
 '\n'    
 '## Function `seq()`\n'    
 '\n'    
 'Return a new sequential value.\n'    
 '\n'    
 '## Function `splitoff(sq, *sizes)`\n'    
 '\n'    
 'Split a sequence into (usually short) prefixes and a tail,\n'    
 'for example to construct subdirectory trees based on a UUID.\n'    
 '\n'    
 'Example:\n'    
 '\n'    
 '    >>> from uuid import UUID\n'    
 "    >>> uuid = 'd6d9c510-785c-468c-9aa4-b7bda343fb79'\n"    
 '    >>> uu = UUID(uuid).hex\n'    
 '    >>> uu\n'    
 "    'd6d9c510785c468c9aa4b7bda343fb79'\n"    
 '    >>> splitoff(uu, 2, 2)\n'    
 "    ['d6', 'd9', 'c510785c468c9aa4b7bda343fb79']\n"    
 '\n'    
 '## Class `StatefulIterator`\n'    
 '\n'    
 'A trivial iterator which wraps another iterator to expose some tracking '    
 'state.\n'    
 '\n'    
 'This has 2 attributes:\n'    
 '* `.it`: the internal iterator which should yield `(item,new_state)`\n'    
 '* `.state`: the last state value from the internal iterator\n'    
 '\n'    
 'The originating use case is resuse of an iterator by independent\n'    
 'calls that are typically sequential, specificly the .read\n'    
 'method of file like objects. Naive sequential reads require\n'    
 'the underlying storage to locate the data on every call, even\n'    
 'though the previous call has just performed this task for the\n'    
 'previous read. Saving the iterator used from the preceeding\n'    
 'call allows the iterator to pick up directly if the file\n'    
 "offset hasn't been fiddled in the meantime.\n"    
 '\n'    
 '## Function `tee(iterable, *Qs)`\n'    
 '\n'    
 'A generator yielding the items from an iterable\n'    
 'which also copies those items to a series of queues.\n'    
 '\n'    
 'Parameters:\n'    
 '* `iterable`: the iterable to copy\n'    
 '* `Qs`: the queues, objects accepting a `.put` method.\n'    
 '\n'    
 'Note: the item is `.put` onto every queue\n'    
 'before being yielded from this generator.\n'    
 '\n'    
 '## Function `the(iterable, context=None)`\n'    
 '\n'    
 'Returns the first element of an iterable, but requires there to be\n'    
 'exactly one.\n'    
 '\n'    
 '## Class `TrackingCounter`\n'    
 '\n'    
 'A wrapper for a counter which can be incremented and decremented.\n'    
 '\n'    
 'A facility is provided to wait for the counter to reach a specific value.\n'    
 'The .inc and .dec methods also accept a `tag` argument to keep\n'    
 'individual counts based on the tag to aid debugging.\n'    
 '\n'    
 'TODO: add `strict` option to error and abort if any counter tries\n'    
 'to go below zero.\n'    
 '\n'    
 '### Method `TrackingCounter.__init__(self, value=0, name=None, lock=None)`\n'    
 '\n'    
 'Initialise the counter to `value` (default 0) with the optional `name`.\n'    
 '\n'    
 '### Method `TrackingCounter.check(self)`\n'    
 '\n'    
 'Internal consistency check.\n'    
 '\n'    
 '### Method `TrackingCounter.dec(self, tag=None)`\n'    
 '\n'    
 'Decrement the counter.\n'    
 'Wake up any threads waiting for its new value.\n'    
 '\n'    
 '### Method `TrackingCounter.inc(self, tag=None)`\n'    
 '\n'    
 'Increment the counter.\n'    
 'Wake up any threads waiting for its new value.\n'    
 '\n'    
 '### Method `TrackingCounter.wait(self, value)`\n'    
 '\n'    
 'Wait for the counter to reach the specified `value`.\n'    
 '\n'    
 '## Function `unrepeated(it, seen=None, signature=None)`\n'    
 '\n'    
 'A generator yielding items from the iterable `it` with no repetitions.\n'    
 '\n'    
 'Parameters:\n'    
 '* `it`: the iterable to process\n'    
 '* `seen`: an optional setlike container supporting `in` and `.add()`\n'    
 '* `signature`: an optional signature function for items from `it`\n'    
 '  which produces the value to compare to recognise repeated items;\n'    
 '  its values are stored in the `seen` set\n'    
 '\n'    
 'The default `signature` function is identity - items are stored and '    
 'compared.\n'    
 'This requires the items to be hashable and support equality tests.\n'    
 'The same applies to whatever values the `signature` function produces.\n'    
 '\n'    
 'Since `seen` accrues all the signature values for yielded items\n'    
 'generally it will grow monotonicly as iteration proceeeds.\n'    
 'If the items are complaex or large it is well worth providing a signature\n'    
 'function even it the items themselves can be used in a set.\n'    
 '\n'    
 '# Release Log\n'    
 '\n'    
 '\n'    
 '\n'    
 '*Release 20210924*:\n'    
 'New greedy(iterable) or @greedy(generator_function) to let generators '    
 'precompute.\n'    
 '\n'    
 '*Release 20210913*:\n'    
 'New unrepeated() generator removing duplicates from an iterable.\n'    
 '\n'    
 '*Release 20201025*:\n'    
 'New splitoff() function to split a sequence into (usually short) prefixes '    
 'and a tail.\n'    
 '\n'    
 '*Release 20200914*:\n'    
 'New common_prefix_length and common_suffix_length for comparing prefixes and '    
 'suffixes of sequences.\n'    
 '\n'    
 '*Release 20190103*:\n'    
 'Documentation update.\n'    
 '\n'    
 '*Release 20190101*:\n'    
 '* New and UNTESTED class StatefulIterator to associate some externally '    
 'visible state with an iterator.\n'    
 '* Seq: accept optional `lock` parameter.\n'    
 '\n'    
 '*Release 20171231*:\n'    
 '* Python 2 backport for imerge().\n'    
 '* New tee function to duplicate an iterable to queues.\n'    
 '* Function isordered() is now a test instead of an assertion.\n'    
 '* Drop NamedTuple, NamedTupleClassFactory (unused).\n'    
 '\n'    
 '*Release 20160918*:\n'    
 '* New function isordered() to test ordering of a sequence.\n'    
 '* imerge: accept new `reverse` parameter for merging reversed iterables.\n'    
 '\n'    
 '*Release 20160828*:\n'    
 'Modify DISTINFO to say "install_requires", fixes pypi requirements.\n'    
 '\n'    
 '*Release 20160827*:\n'    
 'TrackingCounter: accept presupplied lock object. Python 3 exec fix.\n'    
 '\n'    
 '*Release 20150118*:\n'    
 'metadata update\n'    
 '\n'    
 '*Release 20150111*:\n'    
 'Initial PyPI release.'),
  install_requires = ['cs.deco', 'cs.gimmicks', 'cs.queues>=20210924'],
  classifiers = ['Programming Language :: Python', 'Programming Language :: Python :: 2', 'Programming Language :: Python :: 3', 'Development Status :: 4 - Beta', 'Intended Audience :: Developers', 'Operating System :: OS Independent', 'Topic :: Software Development :: Libraries :: Python Modules', 'License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)'],
  keywords = ['python2', 'python3'],
  license = 'GNU General Public License v3 or later (GPLv3+)',
  long_description_content_type = 'text/markdown',
  package_dir = {'': 'lib/python'},
  py_modules = ['cs.seq'],
)
