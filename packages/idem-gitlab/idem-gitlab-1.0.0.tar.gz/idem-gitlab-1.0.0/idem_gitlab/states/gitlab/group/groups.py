"""
Autogenerated using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

Groups
"""
from typing import Any
from typing import Dict

import dict_tools.differ as differ


async def present(
    hub,
    ctx,
    name: str,
    path: str,
    description: str = None,
    membership_lock: bool = None,
    visibility: str = None,
    share_with_group_lock: bool = None,
    require_two_factor_authentication: bool = None,
    two_factor_grace_period: int = None,
    project_creation_level: str = None,
    auto_devops_enabled: bool = None,
    subgroup_creation_level: str = None,
    emails_disabled: bool = None,
    avatar: str = None,
    mentions_disabled: bool = None,
    lfs_enabled: bool = None,
    request_access_enabled: bool = None,
    parent_id: int = None,
    default_branch_protection: int = None,
    shared_runners_minutes_limit: int = None,
    extra_shared_runners_minutes_limit: int = None,
) -> Dict[str, Any]:
    r"""
    **Autogenerated function**

    Parameters:


    Args:
        name(str): The name of the group.
        path(str): The path of the group.
        description(str, optional): The group’s description. Defaults to None.
        membership_lock(bool, optional): Prevent adding new members to project membership within this group. Defaults to None.
        visibility(str, optional): The group’s visibility. Can be private, internal, or public. Defaults to None.
        share_with_group_lock(bool, optional): Prevent sharing a project with another group within this group. Defaults to None.
        require_two_factor_authentication(bool, optional): Require all users in this group to setup Two-factor authentication. Defaults to None.
        two_factor_grace_period(int, optional): Time before Two-factor authentication is enforced (in hours). Defaults to None.
        project_creation_level(str, optional): Determine if developers can create projects in the group. Can be noone (No one), maintainer (Maintainers), or developer (Developers + Maintainers). Defaults to None.
        auto_devops_enabled(bool, optional): Default to Auto DevOps pipeline for all projects within this group. Defaults to None.
        subgroup_creation_level(str, optional): Allowed to create subgroups. Can be owner (Owners), or maintainer (Maintainers). Defaults to None.
        emails_disabled(bool, optional): Disable email notifications. Defaults to None.
        avatar(str, optional): Image file for avatar of the group. Introduced in GitLab 12.9. Defaults to None.
        mentions_disabled(bool, optional): Disable the capability of a group from getting mentioned. Defaults to None.
        lfs_enabled(bool, optional): Enable/disable Large File Storage (LFS) for the projects in this group. Defaults to None.
        request_access_enabled(bool, optional): Allow users to request member access. Defaults to None.
        parent_id(int, optional): The parent group ID for creating nested group. Defaults to None.
        default_branch_protection(int, optional): See Options for default_branch_protection. Default to the global level default branch protection setting. Defaults to None.
        shared_runners_minutes_limit(int, optional): Pipeline minutes quota for this group (included in plan). Can be nil (default; inherit system default), 0 (unlimited) or > 0. Defaults to None.
        extra_shared_runners_minutes_limit(int, optional): Extra pipeline minutes quota for this group (purchased in addition to the minutes included in the plan). Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              gitlab.group.groups.present:
                - name: value
                - path: value
    """

    result = dict(comment="", changes=None, name=name, result=True)

    before = hub.exec.request.json.get(
        ctx,
        url=f"{ctx.acct.endpoint_url}/groups",
        data={"kwargs": '{"id": project_id}'},
        success_codes=[200],
    )
    if before["status"]:
        result["comment"] = f"'{name}' already exists"
    else:
        ret = await hub.exec.request.json.post(
            ctx,
            success_codes=[201, 304, 204],
            url=f"{ctx.acct.endpoint_url}/groups",
            **{
                "name": name,
                "path": path,
                "description": description,
                "membership_lock": membership_lock,
                "visibility": visibility,
                "share_with_group_lock": share_with_group_lock,
                "require_two_factor_authentication": require_two_factor_authentication,
                "two_factor_grace_period": two_factor_grace_period,
                "project_creation_level": project_creation_level,
                "auto_devops_enabled": auto_devops_enabled,
                "subgroup_creation_level": subgroup_creation_level,
                "emails_disabled": emails_disabled,
                "avatar": avatar,
                "mentions_disabled": mentions_disabled,
                "lfs_enabled": lfs_enabled,
                "request_access_enabled": request_access_enabled,
                "parent_id": parent_id,
                "default_branch_protection": default_branch_protection,
                "shared_runners_minutes_limit": shared_runners_minutes_limit,
                "extra_shared_runners_minutes_limit": extra_shared_runners_minutes_limit,
            },
        )
        result["result"] = ret["status"]
        if not result["result"]:
            result["comment"] = ret["comment"]
            return result
        result["comment"] = f"Created '{name}'"

    # Now that the resource exists, update it
    ret = await hub.exec.request.json.put(
        ctx,
        url=f"{ctx.acct.endpoint_url}/groups",
        success_codes=[200, 204, 304],
    )

    if not ret["status"]:
        result["status"] = False
        result["comment"] = f"Unable to update '{name}': {ret['comment']}"

    after = hub.exec.request.json.get(
        ctx,
        url=f"{ctx.acct.endpoint_url}/groups",
        data={"kwargs": '{"id": project_id}'},
        success_codes=[200],
    )
    result["changes"] = differ.deep_diff(before["ret"], after["ret"])
    return result


async def absent(hub, ctx, name: str, project_id: int) -> Dict[str, Any]:
    r"""
    **Autogenerated function**

    Parameters:


    Args:
        name(Text): The identifier for this state.
        project_id(int): The ID or URL-encoded path of the group.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              gitlab.group.groups.absent:
                - name: value
                - project_id: value
    """

    result = dict(comment="", changes=None, name=name, result=True)
    before = hub.exec.request.json.get(
        ctx,
        url=f"{ctx.acct.endpoint_url}/groups",
        data={"kwargs": '{"id": project_id}'},
        success_codes=[204, 304, 404],
    )

    if before["status"]:
        result["comment"] = f"'{name}' already absent"
    else:
        ret = await hub.exec.request.json.delete(
            ctx,
            url=f"{ctx.acct.endpoint_url}/groups",
            success_code=[204],
            **{"id": project_id},
        )
        result["result"] = ret["status"]
        if not result["result"]:
            result["comment"] = ret["comment"]
            return result
        result["comment"] = f"Deleted '{name}'"

    after = hub.exec.request.json.get(
        ctx,
        url=f"{ctx.acct.endpoint_url}/groups",
        data={"kwargs": '{"id": project_id}'},
        success_codes=[204, 304, 404],
    )

    result["changes"] = differ.deep_diff(before["ret"], after["ret"])
    return result


async def describe(hub, ctx) -> Dict[str, Dict[str, Any]]:
    r"""
    **Autogenerated function**

    Describe the resource in a way that can be recreated/managed with the corresponding "present" function


    Parameters:



    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: bash

            $ idem describe gitlab.group.groups
    """

    result = {}

    async for ret in hub.exec.gitlab.request.paginate(
        ctx, url=f"{ctx.acct.endpoint_url}/groups"
    ):
        result[f"group.groups-{ret['id']}"] = {
            "gitlab.group.groups.present": [
                {"name": ret.get("name")},
                {"path": ret.get("path")},
                {"description": ret.get("description")},
                {"membership_lock": ret.get("membership_lock")},
                {"visibility": ret.get("visibility")},
                {"share_with_group_lock": ret.get("share_with_group_lock")},
                {
                    "require_two_factor_authentication": ret.get(
                        "require_two_factor_authentication"
                    )
                },
                {"two_factor_grace_period": ret.get("two_factor_grace_period")},
                {"project_creation_level": ret.get("project_creation_level")},
                {"auto_devops_enabled": ret.get("auto_devops_enabled")},
                {"subgroup_creation_level": ret.get("subgroup_creation_level")},
                {"emails_disabled": ret.get("emails_disabled")},
                {"avatar": ret.get("avatar")},
                {"mentions_disabled": ret.get("mentions_disabled")},
                {"lfs_enabled": ret.get("lfs_enabled")},
                {"request_access_enabled": ret.get("request_access_enabled")},
                {"parent_id": ret.get("parent_id")},
                {"default_branch_protection": ret.get("default_branch_protection")},
                {
                    "shared_runners_minutes_limit": ret.get(
                        "shared_runners_minutes_limit"
                    )
                },
                {
                    "extra_shared_runners_minutes_limit": ret.get(
                        "extra_shared_runners_minutes_limit"
                    )
                },
            ]
        }

    return result
