/*
This file was auto-generated by mupdfwrap.py.
*/


#include "mupdf/exceptions.h"
#include "mupdf/fitz.h"


namespace mupdf
{

ErrorBase::ErrorBase(int code, const char* text)
: m_code(code)
{
	char    code_text[32];
	snprintf(code_text, sizeof(code_text), "%i", code);
	m_text = std::string("code=") + code_text + ": " + text;
};

const char* ErrorBase::what() const throw()
{
	return m_text.c_str();
};


ErrorNone::ErrorNone(const char* text)
: ErrorBase(FZ_ERROR_NONE, text)
{
}


ErrorMemory::ErrorMemory(const char* text)
: ErrorBase(FZ_ERROR_MEMORY, text)
{
}


ErrorGeneric::ErrorGeneric(const char* text)
: ErrorBase(FZ_ERROR_GENERIC, text)
{
}


ErrorSyntax::ErrorSyntax(const char* text)
: ErrorBase(FZ_ERROR_SYNTAX, text)
{
}


ErrorMinor::ErrorMinor(const char* text)
: ErrorBase(FZ_ERROR_MINOR, text)
{
}


ErrorTrylater::ErrorTrylater(const char* text)
: ErrorBase(FZ_ERROR_TRYLATER, text)
{
}


ErrorAbort::ErrorAbort(const char* text)
: ErrorBase(FZ_ERROR_ABORT, text)
{
}


ErrorRepaired::ErrorRepaired(const char* text)
: ErrorBase(FZ_ERROR_REPAIRED, text)
{
}


ErrorCount::ErrorCount(const char* text)
: ErrorBase(FZ_ERROR_COUNT, text)
{
}


void internal_throw_exception(fz_context* ctx)
{
	int code = fz_caught(ctx);
	const char* text = fz_caught_message(ctx);
	if (code == FZ_ERROR_NONE)     throw ErrorNone    (text);
	if (code == FZ_ERROR_MEMORY)   throw ErrorMemory  (text);
	if (code == FZ_ERROR_GENERIC)  throw ErrorGeneric (text);
	if (code == FZ_ERROR_SYNTAX)   throw ErrorSyntax  (text);
	if (code == FZ_ERROR_MINOR)    throw ErrorMinor   (text);
	if (code == FZ_ERROR_TRYLATER) throw ErrorTrylater(text);
	if (code == FZ_ERROR_ABORT)    throw ErrorAbort   (text);
	if (code == FZ_ERROR_REPAIRED) throw ErrorRepaired(text);
	if (code == FZ_ERROR_COUNT)    throw ErrorCount   (text);
	throw ErrorBase(code, fz_caught_message(ctx));
}


} /* End of namespace mupdf. */
