<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>kalash.log API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>kalash.log</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import sys
import logging
from typing import List, Optional, Set, Union, Callable

from .utils import get_ts
from .config import CliConfig, Meta, OneOrList

PathType = Union[os.PathLike, str]

_LOGGERS: Set[logging.Logger] = set()

HANDLERS: List[Callable[..., logging.Handler]] = [lambda n: logging.FileHandler(n)]


def _get_logger_from_state(logger_name: str) -&gt; Optional[logging.Logger]:
    loggers = list(filter(lambda l: l.name == logger_name, _LOGGERS))
    if len(loggers) &gt; 0:
        return loggers[0]
    else:
        return None


def _create_tree_if_not_exists(path: PathType) -&gt; None:
    if not os.path.exists(path):
        os.makedirs(path)


def _make_log_tree_from_id(
    id: str,
    class_name: str,
    meta: Meta,
    groupby: Optional[str] = None
):
    &#34;&#34;&#34;Creates log tree structure representation based on the
    test template keys. By default it does not group
    the logs at all. Any key from the metadata tag
    can be used to group by.

    Args:
        id (str): test ID from the metadata tag
        class_name (str): test class name
        groupby (Optional[str]): what property to group log
            directories by

    Returns:
        A `str` path to the target directory where logs will
            be stored.
    &#34;&#34;&#34;
    dir_name = id + &#39;_&#39; + class_name
    log_name = get_ts(sep=&#39;&#39;) + &#39;_&#39; + dir_name
    full_path = &#34;&#34;
    if groupby:
        _group_dir_name: OneOrList[str] = getattr(meta, groupby)
        group_dir_name: Optional[str] = &#34;&#34;
        if type(_group_dir_name) is list:
            group_dir_name = &#34;_&#34;.join(_group_dir_name)
        elif type(_group_dir_name) is str:
            group_dir_name = _group_dir_name
        else:
            group_dir_name = None
        group_dir_name = group_dir_name if group_dir_name else &#34;unknown_group&#34;
        full_path = os.path.join(dir_name, group_dir_name, log_name)
    else:
        full_path = os.path.join(dir_name, log_name)
    return full_path


def _make_trunk(
    log_name: PathType,
    log_base_path: Optional[PathType] = None
):
    &#34;&#34;&#34;Creates a trunk directory structure
    for the logs if it does not exist, returns
    the path to a concrete log file.
    &#34;&#34;&#34;
    if log_base_path:
        log_path = os.path.join(
            log_base_path,
            log_name
        )

    else:
        log_path = os.path.join(
            &#39;.&#39;,
            log_name
        )

    # create the trunk part (don&#39;t touch the log file name)
    _create_tree_if_not_exists(os.path.dirname(log_path))

    # return the full path with `.log` to the caller
    return log_path + &#39;.log&#39;


def _make_tree(
    id: str,
    class_name: str,
    meta: Meta,
    log_base_path: Optional[PathType] = None,
    groupby: str = None
):
    &#34;&#34;&#34;Combines `_make_trunk_` with `_make_log_tree_from_id`.&#34;&#34;&#34;
    return _make_trunk(
        _make_log_tree_from_id(id, class_name, meta, groupby=groupby),
        log_base_path
    )


def _register_logger(
    logger_name: str,
    log_handlers: List[logging.Handler],
    log_level: int,
    log_format: logging.Formatter
) -&gt; Optional[logging.Logger]:
    &#34;&#34;&#34;
    Creates and registers logger instances.
    &#34;&#34;&#34;
    logger = logging.getLogger(logger_name)
    logger.setLevel(log_level)

    for log_handler in log_handlers:
        log_handler.setFormatter(log_format)
        logger.addHandler(log_handler)

    if logger.name not in [l.name for l in _LOGGERS]:  # noqa: E741
        _LOGGERS.add(logger)
        return logger
    # return `None` if logger already existed!
    return None


def register_logger(
    logger_name: str,
    log_file_path: str,
    config: CliConfig
) -&gt; Optional[logging.Logger]:
    &#34;&#34;&#34;
    Creates and registers logger instances.
    Declares default path handlers and if `no_log_echo`
    is `False` (default) a STDOUT handler will be added
    so all log calls will be echoed to the calling console.

    Args:
        logger_name (str): class name that becomes the unique
            name of the logger. If you have two classes with
            the same name, then the same logger will be used
        log_file_path (str): path to the associated log file
            where logger calls will be written
        config (CliConfig): a `CliConfig` instance representing
            the configuration that the application user
            provided via the CLI

    Return:
        `logging.Logger` instance if a new logger instance
            has been created. `None` if the logger instance
            already existed for this particular `logger_name`
    &#34;&#34;&#34;
    handlers = [f(log_file_path) for f in HANDLERS]
    if not config.no_log_echo:
        # extend with a console handler piping to STDOUT
        # (`logging` uses STDERR by default)
        handlers += [logging.StreamHandler(sys.stdout)]
    return _register_logger(
        logger_name,
        handlers,
        config.log_level,
        logging.Formatter(config.log_format)
    )


def get(
    id: str,
    class_name: str,
    meta: Meta,
    config: CliConfig
) -&gt; logging.Logger:
    &#34;&#34;&#34;Creates or returns an existing `logging.Logger` instance
    associated with a particular `class_name`.

    Args:
        id (str): unique ID of the test
        class_name (str): name of the test class
        config (CliConfig): a `CliConfig` instance representing
            the configuration that the application user
            provided via the CLI

    Returns:
        Associated `logging.Logger` instance
    &#34;&#34;&#34;
    path = _make_tree(id, class_name, meta, config.log_dir, config.group_by)

    l = _get_logger_from_state(class_name)  # noqa: E741

    if not l:
        new_logger = register_logger(class_name, path, config)
        if not new_logger:
            raise ValueError(f&#34;Logger not registered correctly! {class_name}&#34;)
        else:
            return new_logger
    else:
        return l


def close(logger: Union[str, logging.Logger]):
    &#34;&#34;&#34;
    Closes open file handles used by an associated `logger`,
    removes the handlers and removes loggers from
    the managed set.

    Args:
        logger (logging.Logger): the `logging.Logger` instance
            to close

    Returns: `None`
    &#34;&#34;&#34;
    if type(logger) is str:
        l = _get_logger_from_state(logger)  # noqa: E741
    elif type(logger) is logging.Logger:
        l = logger  # noqa: E741
    else:
        raise NameError(
            f&#39;{logger} is not a logger, nor a logger name! &#39;
            &#39;Make sure you use a string or logger instance &#39;
            &#39;with this method.&#39;
        )
    if l:
        for h in l.handlers:
            h.close()
            l.removeHandler(h)
        try:
            _LOGGERS.remove(l)
        except KeyError:
            pass


def close_all():
    &#34;&#34;&#34;
    Forces all loggers to perform a managed `shutdown`.
    Should always be called by the method/function
    running the Kalash tests.
    &#34;&#34;&#34;
    logging.shutdown()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="kalash.log.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>logger: Union[str, logging.Logger])</span>
</code></dt>
<dd>
<div class="desc"><p>Closes open file handles used by an associated <code>logger</code>,
removes the handlers and removes loggers from
the managed set.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>logger</code></strong> :&ensp;<code>logging.Logger</code></dt>
<dd>the <code>logging.Logger</code> instance
to close</dd>
</dl>
<p>Returns: <code>None</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(logger: Union[str, logging.Logger]):
    &#34;&#34;&#34;
    Closes open file handles used by an associated `logger`,
    removes the handlers and removes loggers from
    the managed set.

    Args:
        logger (logging.Logger): the `logging.Logger` instance
            to close

    Returns: `None`
    &#34;&#34;&#34;
    if type(logger) is str:
        l = _get_logger_from_state(logger)  # noqa: E741
    elif type(logger) is logging.Logger:
        l = logger  # noqa: E741
    else:
        raise NameError(
            f&#39;{logger} is not a logger, nor a logger name! &#39;
            &#39;Make sure you use a string or logger instance &#39;
            &#39;with this method.&#39;
        )
    if l:
        for h in l.handlers:
            h.close()
            l.removeHandler(h)
        try:
            _LOGGERS.remove(l)
        except KeyError:
            pass</code></pre>
</details>
</dd>
<dt id="kalash.log.close_all"><code class="name flex">
<span>def <span class="ident">close_all</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Forces all loggers to perform a managed <code>shutdown</code>.
Should always be called by the method/function
running the Kalash tests.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_all():
    &#34;&#34;&#34;
    Forces all loggers to perform a managed `shutdown`.
    Should always be called by the method/function
    running the Kalash tests.
    &#34;&#34;&#34;
    logging.shutdown()</code></pre>
</details>
</dd>
<dt id="kalash.log.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>id: str, class_name: str, meta: <a title="kalash.config.Meta" href="config.html#kalash.config.Meta">Meta</a>, config: <a title="kalash.config.CliConfig" href="config.html#kalash.config.CliConfig">CliConfig</a>) ‑> logging.Logger</span>
</code></dt>
<dd>
<div class="desc"><p>Creates or returns an existing <code>logging.Logger</code> instance
associated with a particular <code>class_name</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>unique ID of the test</dd>
<dt><strong><code>class_name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the test class</dd>
<dt><strong><code>config</code></strong> :&ensp;<code>CliConfig</code></dt>
<dd>a <code>CliConfig</code> instance representing
the configuration that the application user
provided via the CLI</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Associated <code>logging.Logger</code> instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(
    id: str,
    class_name: str,
    meta: Meta,
    config: CliConfig
) -&gt; logging.Logger:
    &#34;&#34;&#34;Creates or returns an existing `logging.Logger` instance
    associated with a particular `class_name`.

    Args:
        id (str): unique ID of the test
        class_name (str): name of the test class
        config (CliConfig): a `CliConfig` instance representing
            the configuration that the application user
            provided via the CLI

    Returns:
        Associated `logging.Logger` instance
    &#34;&#34;&#34;
    path = _make_tree(id, class_name, meta, config.log_dir, config.group_by)

    l = _get_logger_from_state(class_name)  # noqa: E741

    if not l:
        new_logger = register_logger(class_name, path, config)
        if not new_logger:
            raise ValueError(f&#34;Logger not registered correctly! {class_name}&#34;)
        else:
            return new_logger
    else:
        return l</code></pre>
</details>
</dd>
<dt id="kalash.log.register_logger"><code class="name flex">
<span>def <span class="ident">register_logger</span></span>(<span>logger_name: str, log_file_path: str, config: <a title="kalash.config.CliConfig" href="config.html#kalash.config.CliConfig">CliConfig</a>) ‑> Optional[logging.Logger]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and registers logger instances.
Declares default path handlers and if <code>no_log_echo</code>
is <code>False</code> (default) a STDOUT handler will be added
so all log calls will be echoed to the calling console.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>logger_name</code></strong> :&ensp;<code>str</code></dt>
<dd>class name that becomes the unique
name of the logger. If you have two classes with
the same name, then the same logger will be used</dd>
<dt><strong><code>log_file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>path to the associated log file
where logger calls will be written</dd>
<dt><strong><code>config</code></strong> :&ensp;<code>CliConfig</code></dt>
<dd>a <code>CliConfig</code> instance representing
the configuration that the application user
provided via the CLI</dd>
</dl>
<h2 id="return">Return</h2>
<p><code>logging.Logger</code> instance if a new logger instance
has been created. <code>None</code> if the logger instance
already existed for this particular <code>logger_name</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_logger(
    logger_name: str,
    log_file_path: str,
    config: CliConfig
) -&gt; Optional[logging.Logger]:
    &#34;&#34;&#34;
    Creates and registers logger instances.
    Declares default path handlers and if `no_log_echo`
    is `False` (default) a STDOUT handler will be added
    so all log calls will be echoed to the calling console.

    Args:
        logger_name (str): class name that becomes the unique
            name of the logger. If you have two classes with
            the same name, then the same logger will be used
        log_file_path (str): path to the associated log file
            where logger calls will be written
        config (CliConfig): a `CliConfig` instance representing
            the configuration that the application user
            provided via the CLI

    Return:
        `logging.Logger` instance if a new logger instance
            has been created. `None` if the logger instance
            already existed for this particular `logger_name`
    &#34;&#34;&#34;
    handlers = [f(log_file_path) for f in HANDLERS]
    if not config.no_log_echo:
        # extend with a console handler piping to STDOUT
        # (`logging` uses STDERR by default)
        handlers += [logging.StreamHandler(sys.stdout)]
    return _register_logger(
        logger_name,
        handlers,
        config.log_level,
        logging.Formatter(config.log_format)
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="kalash" href="index.html">kalash</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="kalash.log.close" href="#kalash.log.close">close</a></code></li>
<li><code><a title="kalash.log.close_all" href="#kalash.log.close_all">close_all</a></code></li>
<li><code><a title="kalash.log.get" href="#kalash.log.get">get</a></code></li>
<li><code><a title="kalash.log.register_logger" href="#kalash.log.register_logger">register_logger</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>