{"ast":null,"code":"// deepMerge\nfunction emptyTarget(value) {\n  return Array.isArray(value) ? [] : {};\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n  return options.clone !== false && options.isMergeableObject(value) ? deepMerge(emptyTarget(value), value, options) : value;\n}\n\nfunction defaultArrayMerge(target, source, options) {\n  return target.concat(source).map(function (element) {\n    return cloneUnlessOtherwiseSpecified(element, options);\n  });\n}\n\nfunction getMergeFunction(key, options) {\n  if (!options.customMerge) {\n    return deepMerge;\n  }\n\n  var customMerge = options.customMerge(key);\n  return typeof customMerge === 'function' ? customMerge : deepMerge;\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n  // @ts-ignore\n  return Object.getOwnPropertySymbols // @ts-ignore\n  ? Object.getOwnPropertySymbols(target).filter(function (symbol) {\n    return target.propertyIsEnumerable(symbol);\n  }) : [];\n}\n\nfunction getKeys(target) {\n  return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));\n}\n\nfunction propertyIsOnObject(object, property) {\n  try {\n    return property in object;\n  } catch (_) {\n    return false;\n  }\n} // Protects from prototype poisoning and unexpected merging up the prototype chain.\n\n\nfunction propertyIsUnsafe(target, key) {\n  return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n  && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n  && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n  var destination = {};\n\n  if (options.isMergeableObject(target)) {\n    getKeys(target).forEach(function (key) {\n      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n    });\n  }\n\n  getKeys(source).forEach(function (key) {\n    if (propertyIsUnsafe(target, key)) {\n      return;\n    }\n\n    if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n      destination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n    } else {\n      destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n    }\n  });\n  return destination;\n}\n\nfunction defaultIsMergeableObject(value) {\n  return isNonNullObject(value) && !isSpecial(value);\n}\n\nfunction isNonNullObject(value) {\n  return !!value && typeof value === 'object';\n}\n\nfunction isSpecial(value) {\n  var stringValue = Object.prototype.toString.call(value);\n  return stringValue === '[object RegExp]' || stringValue === '[object Date]';\n}\n\nexport function deepMerge(target, source, options) {\n  options = options || {};\n  options.arrayMerge = options.arrayMerge || defaultArrayMerge;\n  options.isMergeableObject = options.isMergeableObject || defaultIsMergeableObject; // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n  // implementations can use it. The caller may not replace it.\n\n  options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n  var sourceIsArray = Array.isArray(source);\n  var targetIsArray = Array.isArray(target);\n  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n  if (!sourceAndTargetTypesMatch) {\n    return cloneUnlessOtherwiseSpecified(source, options);\n  } else if (sourceIsArray) {\n    return options.arrayMerge(target, source, options);\n  } else {\n    return mergeObject(target, source, options);\n  }\n} // END - deep merge\n\nexport function mergeDeep(dest, source, copyUndefined, objectsThatNeedCopy, iteration) {\n  if (copyUndefined === void 0) {\n    copyUndefined = true;\n  }\n\n  if (objectsThatNeedCopy === void 0) {\n    objectsThatNeedCopy = [];\n  }\n\n  if (iteration === void 0) {\n    iteration = 0;\n  }\n\n  if (!exists(source)) {\n    return;\n  }\n\n  iterateObject(source, function (key, sourceValue) {\n    var destValue = dest[key];\n\n    if (destValue === sourceValue) {\n      return;\n    }\n\n    var dontCopyOverSourceObject = iteration == 0 && destValue == null && sourceValue != null && objectsThatNeedCopy.indexOf(key) >= 0;\n\n    if (dontCopyOverSourceObject) {\n      // by putting an empty value into destValue first, it means we end up copying over values from\n      // the source object, rather than just copying in the source object in it's entirety.\n      destValue = {};\n      dest[key] = destValue;\n    }\n\n    if (typeof destValue === 'object' && typeof sourceValue === 'object' && !Array.isArray(destValue)) {\n      mergeDeep(destValue, sourceValue, copyUndefined, objectsThatNeedCopy, iteration++);\n    } else if (copyUndefined || sourceValue !== undefined) {\n      dest[key] = sourceValue;\n    }\n  });\n}\n\nfunction iterateObject(object, callback) {\n  if (object == null) {\n    return;\n  }\n\n  if (Array.isArray(object)) {\n    forEach(object, function (value, index) {\n      return callback(\"\" + index, value);\n    });\n  } else {\n    forEach(Object.keys(object), function (key) {\n      return callback(key, object[key]);\n    });\n  }\n}\n\nexport function exists(value, allowEmptyString) {\n  if (allowEmptyString === void 0) {\n    allowEmptyString = false;\n  }\n\n  return value != null && (allowEmptyString || value !== '');\n}\n\nfunction forEach(list, action) {\n  if (list == null) {\n    return;\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    action(list[i], i);\n  }\n}","map":{"version":3,"sources":["C:/dev/streamlit-aggrid/st_aggrid/frontend/node_modules/@ag-grid-enterprise/charts/dist/es6/charts/chartComp/object.js"],"names":["emptyTarget","value","Array","isArray","cloneUnlessOtherwiseSpecified","options","clone","isMergeableObject","deepMerge","defaultArrayMerge","target","source","concat","map","element","getMergeFunction","key","customMerge","getEnumerableOwnPropertySymbols","Object","getOwnPropertySymbols","filter","symbol","propertyIsEnumerable","getKeys","keys","propertyIsOnObject","object","property","_","propertyIsUnsafe","hasOwnProperty","call","mergeObject","destination","forEach","defaultIsMergeableObject","isNonNullObject","isSpecial","stringValue","prototype","toString","arrayMerge","sourceIsArray","targetIsArray","sourceAndTargetTypesMatch","mergeDeep","dest","copyUndefined","objectsThatNeedCopy","iteration","exists","iterateObject","sourceValue","destValue","dontCopyOverSourceObject","indexOf","undefined","callback","index","allowEmptyString","list","action","i","length"],"mappings":"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","sourcesContent":["// deepMerge\nfunction emptyTarget(value) {\n    return Array.isArray(value) ? [] : {};\n}\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n    return (options.clone !== false && options.isMergeableObject(value))\n        ? deepMerge(emptyTarget(value), value, options)\n        : value;\n}\nfunction defaultArrayMerge(target, source, options) {\n    return target.concat(source).map(function (element) {\n        return cloneUnlessOtherwiseSpecified(element, options);\n    });\n}\nfunction getMergeFunction(key, options) {\n    if (!options.customMerge) {\n        return deepMerge;\n    }\n    var customMerge = options.customMerge(key);\n    return typeof customMerge === 'function' ? customMerge : deepMerge;\n}\nfunction getEnumerableOwnPropertySymbols(target) {\n    // @ts-ignore\n    return Object.getOwnPropertySymbols\n        // @ts-ignore\n        ? Object.getOwnPropertySymbols(target).filter(function (symbol) {\n            return target.propertyIsEnumerable(symbol);\n        })\n        : [];\n}\nfunction getKeys(target) {\n    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));\n}\nfunction propertyIsOnObject(object, property) {\n    try {\n        return property in object;\n    }\n    catch (_) {\n        return false;\n    }\n}\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n        && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n            && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.\n}\nfunction mergeObject(target, source, options) {\n    var destination = {};\n    if (options.isMergeableObject(target)) {\n        getKeys(target).forEach(function (key) {\n            destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n        });\n    }\n    getKeys(source).forEach(function (key) {\n        if (propertyIsUnsafe(target, key)) {\n            return;\n        }\n        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n            destination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n        }\n        else {\n            destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n        }\n    });\n    return destination;\n}\nfunction defaultIsMergeableObject(value) {\n    return isNonNullObject(value) && !isSpecial(value);\n}\nfunction isNonNullObject(value) {\n    return !!value && typeof value === 'object';\n}\nfunction isSpecial(value) {\n    var stringValue = Object.prototype.toString.call(value);\n    return stringValue === '[object RegExp]' || stringValue === '[object Date]';\n}\nexport function deepMerge(target, source, options) {\n    options = options || {};\n    options.arrayMerge = options.arrayMerge || defaultArrayMerge;\n    options.isMergeableObject = options.isMergeableObject || defaultIsMergeableObject;\n    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n    // implementations can use it. The caller may not replace it.\n    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n    var sourceIsArray = Array.isArray(source);\n    var targetIsArray = Array.isArray(target);\n    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n    if (!sourceAndTargetTypesMatch) {\n        return cloneUnlessOtherwiseSpecified(source, options);\n    }\n    else if (sourceIsArray) {\n        return options.arrayMerge(target, source, options);\n    }\n    else {\n        return mergeObject(target, source, options);\n    }\n}\n// END - deep merge\nexport function mergeDeep(dest, source, copyUndefined, objectsThatNeedCopy, iteration) {\n    if (copyUndefined === void 0) { copyUndefined = true; }\n    if (objectsThatNeedCopy === void 0) { objectsThatNeedCopy = []; }\n    if (iteration === void 0) { iteration = 0; }\n    if (!exists(source)) {\n        return;\n    }\n    iterateObject(source, function (key, sourceValue) {\n        var destValue = dest[key];\n        if (destValue === sourceValue) {\n            return;\n        }\n        var dontCopyOverSourceObject = iteration == 0 && destValue == null && sourceValue != null && objectsThatNeedCopy.indexOf(key) >= 0;\n        if (dontCopyOverSourceObject) {\n            // by putting an empty value into destValue first, it means we end up copying over values from\n            // the source object, rather than just copying in the source object in it's entirety.\n            destValue = {};\n            dest[key] = destValue;\n        }\n        if (typeof destValue === 'object' && typeof sourceValue === 'object' && !Array.isArray(destValue)) {\n            mergeDeep(destValue, sourceValue, copyUndefined, objectsThatNeedCopy, iteration++);\n        }\n        else if (copyUndefined || sourceValue !== undefined) {\n            dest[key] = sourceValue;\n        }\n    });\n}\nfunction iterateObject(object, callback) {\n    if (object == null) {\n        return;\n    }\n    if (Array.isArray(object)) {\n        forEach(object, function (value, index) { return callback(\"\" + index, value); });\n    }\n    else {\n        forEach(Object.keys(object), function (key) { return callback(key, object[key]); });\n    }\n}\nexport function exists(value, allowEmptyString) {\n    if (allowEmptyString === void 0) { allowEmptyString = false; }\n    return value != null && (allowEmptyString || value !== '');\n}\nfunction forEach(list, action) {\n    if (list == null) {\n        return;\n    }\n    for (var i = 0; i < list.length; i++) {\n        action(list[i], i);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}