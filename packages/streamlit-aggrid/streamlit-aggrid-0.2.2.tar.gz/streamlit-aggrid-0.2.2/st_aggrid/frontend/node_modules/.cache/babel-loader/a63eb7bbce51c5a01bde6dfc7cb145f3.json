{"ast":null,"code":"import tzTokenizeDate from '../tzTokenizeDate/index.js';\nvar MILLISECONDS_IN_HOUR = 3600000;\nvar MILLISECONDS_IN_MINUTE = 60000;\nvar patterns = {\n  timezone: /([Z+-].*)$/,\n  timezoneZ: /^(Z)$/,\n  timezoneHH: /^([+-])(\\d{2})$/,\n  timezoneHHMM: /^([+-])(\\d{2}):?(\\d{2})$/\n}; // Parse various time zone offset formats to an offset in milliseconds\n\nexport default function tzParseTimezone(timezoneString, date, isUtcDate) {\n  var token;\n  var absoluteOffset; // Z\n\n  token = patterns.timezoneZ.exec(timezoneString);\n\n  if (token) {\n    return 0;\n  }\n\n  var hours; // ±hh\n\n  token = patterns.timezoneHH.exec(timezoneString);\n\n  if (token) {\n    hours = parseInt(token[2], 10);\n\n    if (!validateTimezone(hours)) {\n      return NaN;\n    }\n\n    absoluteOffset = hours * MILLISECONDS_IN_HOUR;\n    return token[1] === '+' ? -absoluteOffset : absoluteOffset;\n  } // ±hh:mm or ±hhmm\n\n\n  token = patterns.timezoneHHMM.exec(timezoneString);\n\n  if (token) {\n    hours = parseInt(token[2], 10);\n    var minutes = parseInt(token[3], 10);\n\n    if (!validateTimezone(hours, minutes)) {\n      return NaN;\n    }\n\n    absoluteOffset = hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;\n    return token[1] === '+' ? -absoluteOffset : absoluteOffset;\n  } // IANA time zone\n\n\n  if (isValidTimezoneIANAString(timezoneString)) {\n    date = new Date(date || Date.now());\n    var utcDate = isUtcDate ? date : toUtcDate(date);\n    var offset = calcOffset(utcDate, timezoneString);\n    var fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString);\n    return -fixedOffset;\n  }\n\n  return 0;\n}\n\nfunction toUtcDate(date) {\n  return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));\n}\n\nfunction calcOffset(date, timezoneString) {\n  var tokens = tzTokenizeDate(date, timezoneString);\n  var asUTC = Date.UTC(tokens[0], tokens[1] - 1, tokens[2], tokens[3] % 24, tokens[4], tokens[5]);\n  var asTS = date.getTime();\n  var over = asTS % 1000;\n  asTS -= over >= 0 ? over : 1000 + over;\n  return asUTC - asTS;\n}\n\nfunction fixOffset(date, offset, timezoneString) {\n  var localTS = date.getTime(); // Our UTC time is just a guess because our offset is just a guess\n\n  var utcGuess = localTS - offset; // Test whether the zone matches the offset for this ts\n\n  var o2 = calcOffset(new Date(utcGuess), timezoneString); // If so, offset didn't change and we're done\n\n  if (offset === o2) {\n    return offset;\n  } // If not, change the ts by the difference in the offset\n\n\n  utcGuess -= o2 - offset; // If that gives us the local time we want, we're done\n\n  var o3 = calcOffset(new Date(utcGuess), timezoneString);\n\n  if (o2 === o3) {\n    return o2;\n  } // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time\n\n\n  return Math.max(o2, o3);\n}\n\nfunction validateTimezone(hours, minutes) {\n  if (minutes != null && (minutes < 0 || minutes > 59)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isValidTimezoneIANAString(timeZoneString) {\n  try {\n    Intl.DateTimeFormat(undefined, {\n      timeZone: timeZoneString\n    });\n    return true;\n  } catch (error) {\n    return false;\n  }\n}","map":{"version":3,"sources":["C:/dev/streamlit-aggrid/st_aggrid/frontend/node_modules/date-fns-tz/esm/_lib/tzParseTimezone/index.js"],"names":["tzTokenizeDate","MILLISECONDS_IN_HOUR","MILLISECONDS_IN_MINUTE","patterns","timezone","timezoneZ","timezoneHH","timezoneHHMM","tzParseTimezone","timezoneString","date","isUtcDate","token","absoluteOffset","exec","hours","parseInt","validateTimezone","NaN","minutes","isValidTimezoneIANAString","Date","now","utcDate","toUtcDate","offset","calcOffset","fixedOffset","fixOffset","UTC","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","tokens","asUTC","asTS","getTime","over","localTS","utcGuess","o2","o3","Math","max","timeZoneString","Intl","DateTimeFormat","undefined","timeZone","error"],"mappings":"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","sourcesContent":["import tzTokenizeDate from '../tzTokenizeDate/index.js'\n\nvar MILLISECONDS_IN_HOUR = 3600000\nvar MILLISECONDS_IN_MINUTE = 60000\n\nvar patterns = {\n  timezone: /([Z+-].*)$/,\n  timezoneZ: /^(Z)$/,\n  timezoneHH: /^([+-])(\\d{2})$/,\n  timezoneHHMM: /^([+-])(\\d{2}):?(\\d{2})$/\n}\n\n// Parse various time zone offset formats to an offset in milliseconds\nexport default function tzParseTimezone(timezoneString, date, isUtcDate) {\n  var token\n  var absoluteOffset\n\n  // Z\n  token = patterns.timezoneZ.exec(timezoneString)\n  if (token) {\n    return 0\n  }\n\n  var hours\n\n  // ±hh\n  token = patterns.timezoneHH.exec(timezoneString)\n  if (token) {\n    hours = parseInt(token[2], 10)\n\n    if (!validateTimezone(hours)) {\n      return NaN\n    }\n\n    absoluteOffset = hours * MILLISECONDS_IN_HOUR\n    return token[1] === '+' ? -absoluteOffset : absoluteOffset\n  }\n\n  // ±hh:mm or ±hhmm\n  token = patterns.timezoneHHMM.exec(timezoneString)\n  if (token) {\n    hours = parseInt(token[2], 10)\n    var minutes = parseInt(token[3], 10)\n\n    if (!validateTimezone(hours, minutes)) {\n      return NaN\n    }\n\n    absoluteOffset = hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE\n    return token[1] === '+' ? -absoluteOffset : absoluteOffset\n  }\n\n  // IANA time zone\n  if (isValidTimezoneIANAString(timezoneString)) {\n    date = new Date(date || Date.now())\n    var utcDate = isUtcDate ? date : toUtcDate(date)\n\n    var offset = calcOffset(utcDate, timezoneString)\n\n    var fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString)\n\n    return -fixedOffset\n  }\n\n  return 0\n}\n\nfunction toUtcDate(date) {\n  return new Date(\n    Date.UTC(\n      date.getFullYear(),\n      date.getMonth(),\n      date.getDate(),\n      date.getHours(),\n      date.getMinutes(),\n      date.getSeconds(),\n      date.getMilliseconds()\n    )\n  )\n}\n\nfunction calcOffset(date, timezoneString) {\n  var tokens = tzTokenizeDate(date, timezoneString)\n\n  var asUTC = Date.UTC(tokens[0], tokens[1] - 1, tokens[2], tokens[3] % 24, tokens[4], tokens[5])\n\n  var asTS = date.getTime()\n  var over = asTS % 1000\n  asTS -= over >= 0 ? over : 1000 + over\n  return asUTC - asTS\n}\n\nfunction fixOffset(date, offset, timezoneString) {\n  var localTS = date.getTime()\n\n  // Our UTC time is just a guess because our offset is just a guess\n  var utcGuess = localTS - offset\n\n  // Test whether the zone matches the offset for this ts\n  var o2 = calcOffset(new Date(utcGuess), timezoneString)\n\n  // If so, offset didn't change and we're done\n  if (offset === o2) {\n    return offset\n  }\n\n  // If not, change the ts by the difference in the offset\n  utcGuess -= o2 - offset\n\n  // If that gives us the local time we want, we're done\n  var o3 = calcOffset(new Date(utcGuess), timezoneString)\n  if (o2 === o3) {\n    return o2\n  }\n\n  // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time\n  return Math.max(o2, o3)\n}\n\nfunction validateTimezone(hours, minutes) {\n  if (minutes != null && (minutes < 0 || minutes > 59)) {\n    return false\n  }\n\n  return true\n}\n\nfunction isValidTimezoneIANAString(timeZoneString) {\n  try {\n    Intl.DateTimeFormat(undefined, {timeZone: timeZoneString});\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}