{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport { Autowired, BeanStub, Events, NumberSequence, PreDestroy, Qualifier, _ } from \"@ag-grid-community/core\";\nimport { InfiniteBlock } from \"./infiniteBlock\";\n\nvar InfiniteCache = function (_super) {\n  __extends(InfiniteCache, _super);\n\n  function InfiniteCache(params) {\n    var _this = _super.call(this) || this;\n\n    _this.lastRowIndexKnown = false;\n    _this.blocks = {};\n    _this.blockCount = 0;\n    _this.rowCount = params.initialRowCount;\n    _this.params = params;\n    return _this;\n  }\n\n  InfiniteCache.prototype.setBeans = function (loggerFactory) {\n    this.logger = loggerFactory.create('InfiniteCache');\n  }; // the rowRenderer will not pass dontCreatePage, meaning when rendering the grid,\n  // it will want new pages in the cache as it asks for rows. only when we are inserting /\n  // removing rows via the api is dontCreatePage set, where we move rows between the pages.\n\n\n  InfiniteCache.prototype.getRow = function (rowIndex, dontCreatePage) {\n    if (dontCreatePage === void 0) {\n      dontCreatePage = false;\n    }\n\n    var blockId = Math.floor(rowIndex / this.params.blockSize);\n    var block = this.blocks[blockId];\n\n    if (!block) {\n      if (dontCreatePage) {\n        return undefined;\n      }\n\n      block = this.createBlock(blockId);\n    }\n\n    return block.getRow(rowIndex);\n  };\n\n  InfiniteCache.prototype.createBlock = function (blockNumber) {\n    var newBlock = this.createBean(new InfiniteBlock(blockNumber, this, this.params));\n    this.blocks[newBlock.getId()] = newBlock;\n    this.blockCount++;\n    this.purgeBlocksIfNeeded(newBlock);\n    this.params.rowNodeBlockLoader.addBlock(newBlock);\n    return newBlock;\n  }; // we have this on infinite row model only, not server side row model,\n  // because for server side, it would leave the children in inconsistent\n  // state - eg if a node had children, but after the refresh it had data\n  // for a different row, then the children would be with the wrong row node.\n\n\n  InfiniteCache.prototype.refreshCache = function () {\n    var nothingToRefresh = this.blockCount == 0;\n\n    if (nothingToRefresh) {\n      this.purgeCache();\n      return;\n    }\n\n    this.getBlocksInOrder().forEach(function (block) {\n      return block.setStateWaitingToLoad();\n    });\n    this.params.rowNodeBlockLoader.checkBlockToLoad();\n  };\n\n  InfiniteCache.prototype.destroyAllBlocks = function () {\n    var _this = this;\n\n    this.getBlocksInOrder().forEach(function (block) {\n      return _this.destroyBlock(block);\n    });\n  };\n\n  InfiniteCache.prototype.getRowCount = function () {\n    return this.rowCount;\n  };\n\n  InfiniteCache.prototype.isLastRowIndexKnown = function () {\n    return this.lastRowIndexKnown;\n  }; // block calls this, when page loaded\n\n\n  InfiniteCache.prototype.pageLoaded = function (block, lastRow) {\n    // if we are not active, then we ignore all events, otherwise we could end up getting the\n    // grid to refresh even though we are no longer the active cache\n    if (!this.isAlive()) {\n      return;\n    }\n\n    this.logger.log(\"onPageLoaded: page = \" + block.getId() + \", lastRow = \" + lastRow);\n    this.checkRowCount(block, lastRow); // we fire cacheUpdated even if the row count has not changed, as some items need updating even\n    // if no new rows to render. for example the pagination panel has '?' as the total rows when loading\n    // is underway, which would need to get updated when loading finishes.\n\n    this.onCacheUpdated();\n  };\n\n  InfiniteCache.prototype.purgeBlocksIfNeeded = function (blockToExclude) {\n    var _this = this; // we exclude checking for the page just created, as this has yet to be accessed and hence\n    // the lastAccessed stamp will not be updated for the first time yet\n\n\n    var blocksForPurging = this.getBlocksInOrder().filter(function (b) {\n      return b != blockToExclude;\n    });\n\n    var lastAccessedComparator = function lastAccessedComparator(a, b) {\n      return b.getLastAccessed() - a.getLastAccessed();\n    };\n\n    blocksForPurging.sort(lastAccessedComparator); // we remove (maxBlocksInCache - 1) as we already excluded the 'just created' page.\n    // in other words, after the splice operation below, we have taken out the blocks\n    // we want to keep, which means we are left with blocks that we can potentially purge\n\n    var maxBlocksProvided = this.params.maxBlocksInCache > 0;\n    var blocksToKeep = maxBlocksProvided ? this.params.maxBlocksInCache - 1 : null;\n    var emptyBlocksToKeep = InfiniteCache.MAX_EMPTY_BLOCKS_TO_KEEP - 1;\n    blocksForPurging.forEach(function (block, index) {\n      var purgeBecauseBlockEmpty = block.getState() === InfiniteBlock.STATE_WAITING_TO_LOAD && index >= emptyBlocksToKeep;\n      var purgeBecauseCacheFull = maxBlocksProvided ? index >= blocksToKeep : false;\n\n      if (purgeBecauseBlockEmpty || purgeBecauseCacheFull) {\n        // if the block currently has rows been displayed, then don't remove it either.\n        // this can happen if user has maxBlocks=2, and blockSize=5 (thus 10 max rows in cache)\n        // but the screen is showing 20 rows, so at least 4 blocks are needed.\n        if (_this.isBlockCurrentlyDisplayed(block)) {\n          return;\n        } // don't want to loose keyboard focus, so keyboard navigation can continue. so keep focused blocks.\n\n\n        if (_this.isBlockFocused(block)) {\n          return;\n        } // at this point, block is not needed, so burn baby burn\n\n\n        _this.removeBlockFromCache(block);\n      }\n    });\n  };\n\n  InfiniteCache.prototype.isBlockFocused = function (block) {\n    var focusedCell = this.focusService.getFocusCellToUseAfterRefresh();\n\n    if (!focusedCell) {\n      return false;\n    }\n\n    if (focusedCell.rowPinned != null) {\n      return false;\n    }\n\n    var blockIndexStart = block.getStartRow();\n    var blockIndexEnd = block.getEndRow();\n    var hasFocus = focusedCell.rowIndex >= blockIndexStart && focusedCell.rowIndex < blockIndexEnd;\n    return hasFocus;\n  };\n\n  InfiniteCache.prototype.isBlockCurrentlyDisplayed = function (block) {\n    var startIndex = block.getStartRow();\n    var endIndex = block.getEndRow() - 1;\n    return this.rowRenderer.isRangeInRenderedViewport(startIndex, endIndex);\n  };\n\n  InfiniteCache.prototype.removeBlockFromCache = function (blockToRemove) {\n    if (!blockToRemove) {\n      return;\n    }\n\n    this.destroyBlock(blockToRemove); // we do not want to remove the 'loaded' event listener, as the\n    // concurrent loads count needs to be updated when the load is complete\n    // if the purged page is in loading state\n  };\n\n  InfiniteCache.prototype.checkRowCount = function (block, lastRow) {\n    // if client provided a last row, we always use it, as it could change between server calls\n    // if user deleted data and then called refresh on the grid.\n    if (typeof lastRow === 'number' && lastRow >= 0) {\n      this.rowCount = lastRow;\n      this.lastRowIndexKnown = true;\n    } else if (!this.lastRowIndexKnown) {\n      // otherwise, see if we need to add some virtual rows\n      var lastRowIndex = (block.getId() + 1) * this.params.blockSize;\n      var lastRowIndexPlusOverflow = lastRowIndex + this.params.overflowSize;\n\n      if (this.rowCount < lastRowIndexPlusOverflow) {\n        this.rowCount = lastRowIndexPlusOverflow;\n      }\n    }\n  };\n\n  InfiniteCache.prototype.setRowCount = function (rowCount, lastRowIndexKnown) {\n    this.rowCount = rowCount; // if undefined is passed, we do not set this value, if one of {true,false}\n    // is passed, we do set the value.\n\n    if (_.exists(lastRowIndexKnown)) {\n      this.lastRowIndexKnown = lastRowIndexKnown;\n    } // if we are still searching, then the row count must not end at the end\n    // of a particular page, otherwise the searching will not pop into the\n    // next page\n\n\n    if (!this.lastRowIndexKnown) {\n      if (this.rowCount % this.params.blockSize === 0) {\n        this.rowCount++;\n      }\n    }\n\n    this.onCacheUpdated();\n  };\n\n  InfiniteCache.prototype.forEachNodeDeep = function (callback) {\n    var _this = this;\n\n    var sequence = new NumberSequence();\n    this.getBlocksInOrder().forEach(function (block) {\n      return block.forEachNode(callback, sequence, _this.rowCount);\n    });\n  };\n\n  InfiniteCache.prototype.getBlocksInOrder = function () {\n    // get all page id's as NUMBERS (not strings, as we need to sort as numbers) and in descending order\n    var blockComparator = function blockComparator(a, b) {\n      return a.getId() - b.getId();\n    };\n\n    var blocks = _.getAllValuesInObject(this.blocks).sort(blockComparator);\n\n    return blocks;\n  };\n\n  InfiniteCache.prototype.destroyBlock = function (block) {\n    delete this.blocks[block.getId()];\n    this.destroyBean(block);\n    this.blockCount--;\n    this.params.rowNodeBlockLoader.removeBlock(block);\n  }; // gets called 1) row count changed 2) cache purged 3) items inserted\n\n\n  InfiniteCache.prototype.onCacheUpdated = function () {\n    if (this.isAlive()) {\n      // if the virtualRowCount is shortened, then it's possible blocks exist that are no longer\n      // in the valid range. so we must remove these. this can happen if user explicitly sets\n      // the virtual row count, or the datasource returns a result and sets lastRow to something\n      // less than virtualRowCount (can happen if user scrolls down, server reduces dataset size).\n      this.destroyAllBlocksPastVirtualRowCount(); // this results in both row models (infinite and server side) firing ModelUpdated,\n      // however server side row model also updates the row indexes first\n\n      var event_1 = {\n        type: Events.EVENT_STORE_UPDATED\n      };\n      this.eventService.dispatchEvent(event_1);\n    }\n  };\n\n  InfiniteCache.prototype.destroyAllBlocksPastVirtualRowCount = function () {\n    var _this = this;\n\n    var blocksToDestroy = [];\n    this.getBlocksInOrder().forEach(function (block) {\n      var startRow = block.getId() * _this.params.blockSize;\n\n      if (startRow >= _this.rowCount) {\n        blocksToDestroy.push(block);\n      }\n    });\n\n    if (blocksToDestroy.length > 0) {\n      blocksToDestroy.forEach(function (block) {\n        return _this.destroyBlock(block);\n      });\n    }\n  };\n\n  InfiniteCache.prototype.purgeCache = function () {\n    var _this = this;\n\n    this.getBlocksInOrder().forEach(function (block) {\n      return _this.removeBlockFromCache(block);\n    });\n    this.lastRowIndexKnown = false; // if zero rows in the cache, we need to get the SSRM to start asking for rows again.\n    // otherwise if set to zero rows last time, and we don't update the row count, then after\n    // the purge there will still be zero rows, meaning the SSRM won't request any rows.\n    // to kick things off, at least one row needs to be asked for.\n\n    if (this.rowCount === 0) {\n      this.rowCount = this.params.initialRowCount;\n    }\n\n    this.onCacheUpdated();\n  };\n\n  InfiniteCache.prototype.getRowNodesInRange = function (firstInRange, lastInRange) {\n    var _this = this;\n\n    var result = [];\n    var lastBlockId = -1;\n    var inActiveRange = false;\n    var numberSequence = new NumberSequence(); // if only one node passed, we start the selection at the top\n\n    if (_.missing(firstInRange)) {\n      inActiveRange = true;\n    }\n\n    var foundGapInSelection = false;\n    this.getBlocksInOrder().forEach(function (block) {\n      if (foundGapInSelection) {\n        return;\n      }\n\n      if (inActiveRange && lastBlockId + 1 !== block.getId()) {\n        foundGapInSelection = true;\n        return;\n      }\n\n      lastBlockId = block.getId();\n      block.forEachNode(function (rowNode) {\n        var hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;\n\n        if (inActiveRange || hitFirstOrLast) {\n          result.push(rowNode);\n        }\n\n        if (hitFirstOrLast) {\n          inActiveRange = !inActiveRange;\n        }\n      }, numberSequence, _this.rowCount);\n    }); // inActiveRange will be still true if we never hit the second rowNode\n\n    var invalidRange = foundGapInSelection || inActiveRange;\n    return invalidRange ? [] : result;\n  }; // this property says how many empty blocks should be in a cache, eg if scrolls down fast and creates 10\n  // blocks all for loading, the grid will only load the last 2 - it will assume the blocks the user quickly\n  // scrolled over are not needed to be loaded.\n\n\n  InfiniteCache.MAX_EMPTY_BLOCKS_TO_KEEP = 2;\n\n  __decorate([Autowired('rowRenderer')], InfiniteCache.prototype, \"rowRenderer\", void 0);\n\n  __decorate([Autowired(\"focusService\")], InfiniteCache.prototype, \"focusService\", void 0);\n\n  __decorate([__param(0, Qualifier('loggerFactory'))], InfiniteCache.prototype, \"setBeans\", null);\n\n  __decorate([PreDestroy], InfiniteCache.prototype, \"destroyAllBlocks\", null);\n\n  return InfiniteCache;\n}(BeanStub);\n\nexport { InfiniteCache };","map":{"version":3,"sources":["C:/dev/streamlit-aggrid/st_aggrid/frontend/node_modules/@ag-grid-community/infinite-row-model/dist/es6/infiniteRowModel/infiniteCache.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","Autowired","BeanStub","Events","NumberSequence","PreDestroy","Qualifier","_","InfiniteBlock","InfiniteCache","_super","params","_this","call","lastRowIndexKnown","blocks","blockCount","rowCount","initialRowCount","setBeans","loggerFactory","logger","getRow","rowIndex","dontCreatePage","blockId","Math","floor","blockSize","block","undefined","createBlock","blockNumber","newBlock","createBean","getId","purgeBlocksIfNeeded","rowNodeBlockLoader","addBlock","refreshCache","nothingToRefresh","purgeCache","getBlocksInOrder","forEach","setStateWaitingToLoad","checkBlockToLoad","destroyAllBlocks","destroyBlock","getRowCount","isLastRowIndexKnown","pageLoaded","lastRow","isAlive","log","checkRowCount","onCacheUpdated","blockToExclude","blocksForPurging","filter","lastAccessedComparator","a","getLastAccessed","sort","maxBlocksProvided","maxBlocksInCache","blocksToKeep","emptyBlocksToKeep","MAX_EMPTY_BLOCKS_TO_KEEP","index","purgeBecauseBlockEmpty","getState","STATE_WAITING_TO_LOAD","purgeBecauseCacheFull","isBlockCurrentlyDisplayed","isBlockFocused","removeBlockFromCache","focusedCell","focusService","getFocusCellToUseAfterRefresh","rowPinned","blockIndexStart","getStartRow","blockIndexEnd","getEndRow","hasFocus","startIndex","endIndex","rowRenderer","isRangeInRenderedViewport","blockToRemove","lastRowIndex","lastRowIndexPlusOverflow","overflowSize","setRowCount","exists","forEachNodeDeep","callback","sequence","forEachNode","blockComparator","getAllValuesInObject","destroyBean","removeBlock","destroyAllBlocksPastVirtualRowCount","event_1","type","EVENT_STORE_UPDATED","eventService","dispatchEvent","blocksToDestroy","startRow","push","getRowNodesInRange","firstInRange","lastInRange","result","lastBlockId","inActiveRange","numberSequence","missing","foundGapInSelection","rowNode","hitFirstOrLast","invalidRange"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Autowired, BeanStub, Events, NumberSequence, PreDestroy, Qualifier, _ } from \"@ag-grid-community/core\";\nimport { InfiniteBlock } from \"./infiniteBlock\";\nvar InfiniteCache = /** @class */ (function (_super) {\n    __extends(InfiniteCache, _super);\n    function InfiniteCache(params) {\n        var _this = _super.call(this) || this;\n        _this.lastRowIndexKnown = false;\n        _this.blocks = {};\n        _this.blockCount = 0;\n        _this.rowCount = params.initialRowCount;\n        _this.params = params;\n        return _this;\n    }\n    InfiniteCache.prototype.setBeans = function (loggerFactory) {\n        this.logger = loggerFactory.create('InfiniteCache');\n    };\n    // the rowRenderer will not pass dontCreatePage, meaning when rendering the grid,\n    // it will want new pages in the cache as it asks for rows. only when we are inserting /\n    // removing rows via the api is dontCreatePage set, where we move rows between the pages.\n    InfiniteCache.prototype.getRow = function (rowIndex, dontCreatePage) {\n        if (dontCreatePage === void 0) { dontCreatePage = false; }\n        var blockId = Math.floor(rowIndex / this.params.blockSize);\n        var block = this.blocks[blockId];\n        if (!block) {\n            if (dontCreatePage) {\n                return undefined;\n            }\n            block = this.createBlock(blockId);\n        }\n        return block.getRow(rowIndex);\n    };\n    InfiniteCache.prototype.createBlock = function (blockNumber) {\n        var newBlock = this.createBean(new InfiniteBlock(blockNumber, this, this.params));\n        this.blocks[newBlock.getId()] = newBlock;\n        this.blockCount++;\n        this.purgeBlocksIfNeeded(newBlock);\n        this.params.rowNodeBlockLoader.addBlock(newBlock);\n        return newBlock;\n    };\n    // we have this on infinite row model only, not server side row model,\n    // because for server side, it would leave the children in inconsistent\n    // state - eg if a node had children, but after the refresh it had data\n    // for a different row, then the children would be with the wrong row node.\n    InfiniteCache.prototype.refreshCache = function () {\n        var nothingToRefresh = this.blockCount == 0;\n        if (nothingToRefresh) {\n            this.purgeCache();\n            return;\n        }\n        this.getBlocksInOrder().forEach(function (block) { return block.setStateWaitingToLoad(); });\n        this.params.rowNodeBlockLoader.checkBlockToLoad();\n    };\n    InfiniteCache.prototype.destroyAllBlocks = function () {\n        var _this = this;\n        this.getBlocksInOrder().forEach(function (block) { return _this.destroyBlock(block); });\n    };\n    InfiniteCache.prototype.getRowCount = function () {\n        return this.rowCount;\n    };\n    InfiniteCache.prototype.isLastRowIndexKnown = function () {\n        return this.lastRowIndexKnown;\n    };\n    // block calls this, when page loaded\n    InfiniteCache.prototype.pageLoaded = function (block, lastRow) {\n        // if we are not active, then we ignore all events, otherwise we could end up getting the\n        // grid to refresh even though we are no longer the active cache\n        if (!this.isAlive()) {\n            return;\n        }\n        this.logger.log(\"onPageLoaded: page = \" + block.getId() + \", lastRow = \" + lastRow);\n        this.checkRowCount(block, lastRow);\n        // we fire cacheUpdated even if the row count has not changed, as some items need updating even\n        // if no new rows to render. for example the pagination panel has '?' as the total rows when loading\n        // is underway, which would need to get updated when loading finishes.\n        this.onCacheUpdated();\n    };\n    InfiniteCache.prototype.purgeBlocksIfNeeded = function (blockToExclude) {\n        var _this = this;\n        // we exclude checking for the page just created, as this has yet to be accessed and hence\n        // the lastAccessed stamp will not be updated for the first time yet\n        var blocksForPurging = this.getBlocksInOrder().filter(function (b) { return b != blockToExclude; });\n        var lastAccessedComparator = function (a, b) { return b.getLastAccessed() - a.getLastAccessed(); };\n        blocksForPurging.sort(lastAccessedComparator);\n        // we remove (maxBlocksInCache - 1) as we already excluded the 'just created' page.\n        // in other words, after the splice operation below, we have taken out the blocks\n        // we want to keep, which means we are left with blocks that we can potentially purge\n        var maxBlocksProvided = this.params.maxBlocksInCache > 0;\n        var blocksToKeep = maxBlocksProvided ? this.params.maxBlocksInCache - 1 : null;\n        var emptyBlocksToKeep = InfiniteCache.MAX_EMPTY_BLOCKS_TO_KEEP - 1;\n        blocksForPurging.forEach(function (block, index) {\n            var purgeBecauseBlockEmpty = block.getState() === InfiniteBlock.STATE_WAITING_TO_LOAD && index >= emptyBlocksToKeep;\n            var purgeBecauseCacheFull = maxBlocksProvided ? index >= blocksToKeep : false;\n            if (purgeBecauseBlockEmpty || purgeBecauseCacheFull) {\n                // if the block currently has rows been displayed, then don't remove it either.\n                // this can happen if user has maxBlocks=2, and blockSize=5 (thus 10 max rows in cache)\n                // but the screen is showing 20 rows, so at least 4 blocks are needed.\n                if (_this.isBlockCurrentlyDisplayed(block)) {\n                    return;\n                }\n                // don't want to loose keyboard focus, so keyboard navigation can continue. so keep focused blocks.\n                if (_this.isBlockFocused(block)) {\n                    return;\n                }\n                // at this point, block is not needed, so burn baby burn\n                _this.removeBlockFromCache(block);\n            }\n        });\n    };\n    InfiniteCache.prototype.isBlockFocused = function (block) {\n        var focusedCell = this.focusService.getFocusCellToUseAfterRefresh();\n        if (!focusedCell) {\n            return false;\n        }\n        if (focusedCell.rowPinned != null) {\n            return false;\n        }\n        var blockIndexStart = block.getStartRow();\n        var blockIndexEnd = block.getEndRow();\n        var hasFocus = focusedCell.rowIndex >= blockIndexStart && focusedCell.rowIndex < blockIndexEnd;\n        return hasFocus;\n    };\n    InfiniteCache.prototype.isBlockCurrentlyDisplayed = function (block) {\n        var startIndex = block.getStartRow();\n        var endIndex = block.getEndRow() - 1;\n        return this.rowRenderer.isRangeInRenderedViewport(startIndex, endIndex);\n    };\n    InfiniteCache.prototype.removeBlockFromCache = function (blockToRemove) {\n        if (!blockToRemove) {\n            return;\n        }\n        this.destroyBlock(blockToRemove);\n        // we do not want to remove the 'loaded' event listener, as the\n        // concurrent loads count needs to be updated when the load is complete\n        // if the purged page is in loading state\n    };\n    InfiniteCache.prototype.checkRowCount = function (block, lastRow) {\n        // if client provided a last row, we always use it, as it could change between server calls\n        // if user deleted data and then called refresh on the grid.\n        if (typeof lastRow === 'number' && lastRow >= 0) {\n            this.rowCount = lastRow;\n            this.lastRowIndexKnown = true;\n        }\n        else if (!this.lastRowIndexKnown) {\n            // otherwise, see if we need to add some virtual rows\n            var lastRowIndex = (block.getId() + 1) * this.params.blockSize;\n            var lastRowIndexPlusOverflow = lastRowIndex + this.params.overflowSize;\n            if (this.rowCount < lastRowIndexPlusOverflow) {\n                this.rowCount = lastRowIndexPlusOverflow;\n            }\n        }\n    };\n    InfiniteCache.prototype.setRowCount = function (rowCount, lastRowIndexKnown) {\n        this.rowCount = rowCount;\n        // if undefined is passed, we do not set this value, if one of {true,false}\n        // is passed, we do set the value.\n        if (_.exists(lastRowIndexKnown)) {\n            this.lastRowIndexKnown = lastRowIndexKnown;\n        }\n        // if we are still searching, then the row count must not end at the end\n        // of a particular page, otherwise the searching will not pop into the\n        // next page\n        if (!this.lastRowIndexKnown) {\n            if (this.rowCount % this.params.blockSize === 0) {\n                this.rowCount++;\n            }\n        }\n        this.onCacheUpdated();\n    };\n    InfiniteCache.prototype.forEachNodeDeep = function (callback) {\n        var _this = this;\n        var sequence = new NumberSequence();\n        this.getBlocksInOrder().forEach(function (block) { return block.forEachNode(callback, sequence, _this.rowCount); });\n    };\n    InfiniteCache.prototype.getBlocksInOrder = function () {\n        // get all page id's as NUMBERS (not strings, as we need to sort as numbers) and in descending order\n        var blockComparator = function (a, b) { return a.getId() - b.getId(); };\n        var blocks = _.getAllValuesInObject(this.blocks).sort(blockComparator);\n        return blocks;\n    };\n    InfiniteCache.prototype.destroyBlock = function (block) {\n        delete this.blocks[block.getId()];\n        this.destroyBean(block);\n        this.blockCount--;\n        this.params.rowNodeBlockLoader.removeBlock(block);\n    };\n    // gets called 1) row count changed 2) cache purged 3) items inserted\n    InfiniteCache.prototype.onCacheUpdated = function () {\n        if (this.isAlive()) {\n            // if the virtualRowCount is shortened, then it's possible blocks exist that are no longer\n            // in the valid range. so we must remove these. this can happen if user explicitly sets\n            // the virtual row count, or the datasource returns a result and sets lastRow to something\n            // less than virtualRowCount (can happen if user scrolls down, server reduces dataset size).\n            this.destroyAllBlocksPastVirtualRowCount();\n            // this results in both row models (infinite and server side) firing ModelUpdated,\n            // however server side row model also updates the row indexes first\n            var event_1 = {\n                type: Events.EVENT_STORE_UPDATED\n            };\n            this.eventService.dispatchEvent(event_1);\n        }\n    };\n    InfiniteCache.prototype.destroyAllBlocksPastVirtualRowCount = function () {\n        var _this = this;\n        var blocksToDestroy = [];\n        this.getBlocksInOrder().forEach(function (block) {\n            var startRow = block.getId() * _this.params.blockSize;\n            if (startRow >= _this.rowCount) {\n                blocksToDestroy.push(block);\n            }\n        });\n        if (blocksToDestroy.length > 0) {\n            blocksToDestroy.forEach(function (block) { return _this.destroyBlock(block); });\n        }\n    };\n    InfiniteCache.prototype.purgeCache = function () {\n        var _this = this;\n        this.getBlocksInOrder().forEach(function (block) { return _this.removeBlockFromCache(block); });\n        this.lastRowIndexKnown = false;\n        // if zero rows in the cache, we need to get the SSRM to start asking for rows again.\n        // otherwise if set to zero rows last time, and we don't update the row count, then after\n        // the purge there will still be zero rows, meaning the SSRM won't request any rows.\n        // to kick things off, at least one row needs to be asked for.\n        if (this.rowCount === 0) {\n            this.rowCount = this.params.initialRowCount;\n        }\n        this.onCacheUpdated();\n    };\n    InfiniteCache.prototype.getRowNodesInRange = function (firstInRange, lastInRange) {\n        var _this = this;\n        var result = [];\n        var lastBlockId = -1;\n        var inActiveRange = false;\n        var numberSequence = new NumberSequence();\n        // if only one node passed, we start the selection at the top\n        if (_.missing(firstInRange)) {\n            inActiveRange = true;\n        }\n        var foundGapInSelection = false;\n        this.getBlocksInOrder().forEach(function (block) {\n            if (foundGapInSelection) {\n                return;\n            }\n            if (inActiveRange && (lastBlockId + 1 !== block.getId())) {\n                foundGapInSelection = true;\n                return;\n            }\n            lastBlockId = block.getId();\n            block.forEachNode(function (rowNode) {\n                var hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;\n                if (inActiveRange || hitFirstOrLast) {\n                    result.push(rowNode);\n                }\n                if (hitFirstOrLast) {\n                    inActiveRange = !inActiveRange;\n                }\n            }, numberSequence, _this.rowCount);\n        });\n        // inActiveRange will be still true if we never hit the second rowNode\n        var invalidRange = foundGapInSelection || inActiveRange;\n        return invalidRange ? [] : result;\n    };\n    // this property says how many empty blocks should be in a cache, eg if scrolls down fast and creates 10\n    // blocks all for loading, the grid will only load the last 2 - it will assume the blocks the user quickly\n    // scrolled over are not needed to be loaded.\n    InfiniteCache.MAX_EMPTY_BLOCKS_TO_KEEP = 2;\n    __decorate([\n        Autowired('rowRenderer')\n    ], InfiniteCache.prototype, \"rowRenderer\", void 0);\n    __decorate([\n        Autowired(\"focusService\")\n    ], InfiniteCache.prototype, \"focusService\", void 0);\n    __decorate([\n        __param(0, Qualifier('loggerFactory'))\n    ], InfiniteCache.prototype, \"setBeans\", null);\n    __decorate([\n        PreDestroy\n    ], InfiniteCache.prototype, \"destroyAllBlocks\", null);\n    return InfiniteCache;\n}(BeanStub));\nexport { InfiniteCache };\n"]},"metadata":{},"sourceType":"module"}