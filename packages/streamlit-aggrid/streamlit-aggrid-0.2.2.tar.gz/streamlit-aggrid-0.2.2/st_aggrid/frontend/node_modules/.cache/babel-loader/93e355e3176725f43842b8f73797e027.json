{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { Path } from \"./path\";\nimport { Shape } from \"./shape\";\nimport { BBox } from \"../bbox\";\nimport { LinearGradient } from \"../gradient/linearGradient\";\nimport { Color } from \"../../util/color\";\nexport var RectSizing;\n\n(function (RectSizing) {\n  RectSizing[RectSizing[\"Content\"] = 0] = \"Content\";\n  RectSizing[RectSizing[\"Border\"] = 1] = \"Border\";\n})(RectSizing || (RectSizing = {}));\n\nvar Rect = function (_super) {\n  __extends(Rect, _super);\n\n  function Rect() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._x = 0;\n    _this._y = 0;\n    _this._width = 10;\n    _this._height = 10;\n    _this._radius = 0;\n    /**\n     * If `true`, the rect is aligned to the pixel grid for crisp looking lines.\n     * Animated rects may not look nice with this option enabled, for example\n     * when a rect is translated by a sub-pixel value on each frame.\n     */\n\n    _this._crisp = false;\n    _this._gradient = false;\n    _this.effectiveStrokeWidth = Shape.defaultStyles.strokeWidth;\n    /**\n     * Similar to https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing\n     */\n\n    _this._sizing = RectSizing.Content;\n    return _this;\n  }\n\n  Object.defineProperty(Rect.prototype, \"x\", {\n    get: function () {\n      return this._x;\n    },\n    set: function (value) {\n      if (this._x !== value) {\n        this._x = value;\n        this.dirtyPath = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Rect.prototype, \"y\", {\n    get: function () {\n      return this._y;\n    },\n    set: function (value) {\n      if (this._y !== value) {\n        this._y = value;\n        this.dirtyPath = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Rect.prototype, \"width\", {\n    get: function () {\n      return this._width;\n    },\n    set: function (value) {\n      if (this._width !== value) {\n        this._width = value;\n        this.dirtyPath = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Rect.prototype, \"height\", {\n    get: function () {\n      return this._height;\n    },\n    set: function (value) {\n      if (this._height !== value) {\n        this._height = value;\n        this.dirtyPath = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Rect.prototype, \"radius\", {\n    get: function () {\n      return this._radius;\n    },\n    set: function (value) {\n      if (this._radius !== value) {\n        this._radius = value;\n        this.dirtyPath = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Rect.prototype, \"crisp\", {\n    get: function () {\n      return this._crisp;\n    },\n    set: function (value) {\n      if (this._crisp !== value) {\n        this._crisp = value;\n        this.dirtyPath = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Rect.prototype, \"gradient\", {\n    get: function () {\n      return this._gradient;\n    },\n    set: function (value) {\n      if (this._gradient !== value) {\n        this._gradient = value;\n        this.updateGradientInstance();\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Rect.prototype.updateGradientInstance = function () {\n    if (this.gradient) {\n      var fill = this.fill;\n\n      if (fill) {\n        var gradient = new LinearGradient();\n        gradient.angle = 270;\n        gradient.stops = [{\n          offset: 0,\n          color: Color.fromString(fill).brighter().toString()\n        }, {\n          offset: 1,\n          color: Color.fromString(fill).darker().toString()\n        }];\n        this.gradientInstance = gradient;\n      }\n    } else {\n      this.gradientInstance = undefined;\n    }\n  };\n\n  Object.defineProperty(Rect.prototype, \"fill\", {\n    get: function () {\n      return this._fill;\n    },\n    set: function (value) {\n      if (this._fill !== value) {\n        this._fill = value;\n        this.updateGradientInstance();\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Rect.prototype, \"strokeWidth\", {\n    get: function () {\n      return this._strokeWidth;\n    },\n    set: function (value) {\n      if (this._strokeWidth !== value) {\n        this._strokeWidth = value; // Normally, when the `lineWidth` changes, we only need to repaint the rect\n        // without updating the path. If the `isCrisp` is set to `true` however,\n        // we need to update the path to make sure the new stroke aligns to\n        // the pixel grid. This is the reason we override the `lineWidth` setter\n        // and getter here.\n\n        if (this.crisp || this.sizing === RectSizing.Border) {\n          this.dirtyPath = true;\n        } else {\n          this.effectiveStrokeWidth = value;\n          this.dirty = true;\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Rect.prototype, \"sizing\", {\n    get: function () {\n      return this._sizing;\n    },\n    set: function (value) {\n      if (this._sizing !== value) {\n        this._sizing = value;\n        this.dirtyPath = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Rect.prototype.updatePath = function () {\n    var borderSizing = this.sizing === RectSizing.Border;\n    var path = this.path;\n    path.clear();\n    var x = this.x;\n    var y = this.y;\n    var width = this.width;\n    var height = this.height;\n    var strokeWidth;\n\n    if (borderSizing) {\n      var halfWidth = width / 2;\n      var halfHeight = height / 2;\n      strokeWidth = Math.min(this.strokeWidth, halfWidth, halfHeight);\n      x = Math.min(x + strokeWidth / 2, x + halfWidth);\n      y = Math.min(y + strokeWidth / 2, y + halfHeight);\n      width = Math.max(width - strokeWidth, 0);\n      height = Math.max(height - strokeWidth, 0);\n    } else {\n      strokeWidth = this.strokeWidth;\n    }\n\n    this.effectiveStrokeWidth = strokeWidth;\n\n    if (this.crisp && !borderSizing) {\n      var _a = this,\n          a = _a.alignment,\n          al = _a.align;\n\n      path.rect(al(a, x), al(a, y), al(a, x, width), al(a, y, height));\n    } else {\n      path.rect(x, y, width, height);\n    }\n  };\n\n  Rect.prototype.computeBBox = function () {\n    var _a = this,\n        x = _a.x,\n        y = _a.y,\n        width = _a.width,\n        height = _a.height;\n\n    return new BBox(x, y, width, height);\n  };\n\n  Rect.prototype.isPointInPath = function (x, y) {\n    var point = this.transformPoint(x, y);\n    var bbox = this.computeBBox();\n    return bbox.containsPoint(point.x, point.y);\n  };\n\n  Rect.prototype.isPointInStroke = function (x, y) {\n    return false;\n  };\n\n  Rect.prototype.fillStroke = function (ctx) {\n    if (!this.scene) {\n      return;\n    }\n\n    var pixelRatio = this.scene.canvas.pixelRatio || 1;\n\n    if (this.fill) {\n      if (this.gradientInstance) {\n        ctx.fillStyle = this.gradientInstance.generateGradient(ctx, this.computeBBox());\n      } else {\n        ctx.fillStyle = this.fill;\n      }\n\n      ctx.globalAlpha = this.opacity * this.fillOpacity; // The canvas context scaling (depends on the device's pixel ratio)\n      // has no effect on shadows, so we have to account for the pixel ratio\n      // manually here.\n\n      var fillShadow = this.fillShadow;\n\n      if (fillShadow && fillShadow.enabled) {\n        ctx.shadowColor = fillShadow.color;\n        ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n        ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n        ctx.shadowBlur = fillShadow.blur * pixelRatio;\n      }\n\n      ctx.fill();\n    }\n\n    ctx.shadowColor = 'rgba(0, 0, 0, 0)';\n\n    if (this.stroke && this.effectiveStrokeWidth) {\n      ctx.strokeStyle = this.stroke;\n      ctx.globalAlpha = this.opacity * this.strokeOpacity;\n      ctx.lineWidth = this.effectiveStrokeWidth;\n\n      if (this.lineDash) {\n        ctx.setLineDash(this.lineDash);\n      }\n\n      if (this.lineDashOffset) {\n        ctx.lineDashOffset = this.lineDashOffset;\n      }\n\n      if (this.lineCap) {\n        ctx.lineCap = this.lineCap;\n      }\n\n      if (this.lineJoin) {\n        ctx.lineJoin = this.lineJoin;\n      }\n\n      var strokeShadow = this.strokeShadow;\n\n      if (strokeShadow && strokeShadow.enabled) {\n        ctx.shadowColor = strokeShadow.color;\n        ctx.shadowOffsetX = strokeShadow.xOffset * pixelRatio;\n        ctx.shadowOffsetY = strokeShadow.yOffset * pixelRatio;\n        ctx.shadowBlur = strokeShadow.blur * pixelRatio;\n      }\n\n      ctx.stroke();\n    }\n  };\n\n  Rect.className = 'Rect';\n  return Rect;\n}(Path);\n\nexport { Rect };","map":{"version":3,"sources":["C:/dev/streamlit-aggrid/st_aggrid/frontend/node_modules/ag-charts-community/dist/es6/scene/shape/rect.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","Path","Shape","BBox","LinearGradient","Color","RectSizing","Rect","_super","_this","apply","arguments","_x","_y","_width","_height","_radius","_crisp","_gradient","effectiveStrokeWidth","defaultStyles","strokeWidth","_sizing","Content","defineProperty","get","set","value","dirtyPath","enumerable","configurable","updateGradientInstance","dirty","gradient","fill","angle","stops","offset","color","fromString","brighter","toString","darker","gradientInstance","undefined","_fill","_strokeWidth","crisp","sizing","Border","updatePath","borderSizing","path","clear","x","y","width","height","halfWidth","halfHeight","Math","min","max","_a","a","alignment","al","align","rect","computeBBox","isPointInPath","point","transformPoint","bbox","containsPoint","isPointInStroke","fillStroke","ctx","scene","pixelRatio","canvas","fillStyle","generateGradient","globalAlpha","opacity","fillOpacity","fillShadow","enabled","shadowColor","shadowOffsetX","xOffset","shadowOffsetY","yOffset","shadowBlur","blur","stroke","strokeStyle","strokeOpacity","lineWidth","lineDash","setLineDash","lineDashOffset","lineCap","lineJoin","strokeShadow","className"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Path } from \"./path\";\nimport { Shape } from \"./shape\";\nimport { BBox } from \"../bbox\";\nimport { LinearGradient } from \"../gradient/linearGradient\";\nimport { Color } from \"../../util/color\";\nexport var RectSizing;\n(function (RectSizing) {\n    RectSizing[RectSizing[\"Content\"] = 0] = \"Content\";\n    RectSizing[RectSizing[\"Border\"] = 1] = \"Border\";\n})(RectSizing || (RectSizing = {}));\nvar Rect = /** @class */ (function (_super) {\n    __extends(Rect, _super);\n    function Rect() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._x = 0;\n        _this._y = 0;\n        _this._width = 10;\n        _this._height = 10;\n        _this._radius = 0;\n        /**\n         * If `true`, the rect is aligned to the pixel grid for crisp looking lines.\n         * Animated rects may not look nice with this option enabled, for example\n         * when a rect is translated by a sub-pixel value on each frame.\n         */\n        _this._crisp = false;\n        _this._gradient = false;\n        _this.effectiveStrokeWidth = Shape.defaultStyles.strokeWidth;\n        /**\n         * Similar to https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing\n         */\n        _this._sizing = RectSizing.Content;\n        return _this;\n    }\n    Object.defineProperty(Rect.prototype, \"x\", {\n        get: function () {\n            return this._x;\n        },\n        set: function (value) {\n            if (this._x !== value) {\n                this._x = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"y\", {\n        get: function () {\n            return this._y;\n        },\n        set: function (value) {\n            if (this._y !== value) {\n                this._y = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"width\", {\n        get: function () {\n            return this._width;\n        },\n        set: function (value) {\n            if (this._width !== value) {\n                this._width = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"height\", {\n        get: function () {\n            return this._height;\n        },\n        set: function (value) {\n            if (this._height !== value) {\n                this._height = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"radius\", {\n        get: function () {\n            return this._radius;\n        },\n        set: function (value) {\n            if (this._radius !== value) {\n                this._radius = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"crisp\", {\n        get: function () {\n            return this._crisp;\n        },\n        set: function (value) {\n            if (this._crisp !== value) {\n                this._crisp = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"gradient\", {\n        get: function () {\n            return this._gradient;\n        },\n        set: function (value) {\n            if (this._gradient !== value) {\n                this._gradient = value;\n                this.updateGradientInstance();\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Rect.prototype.updateGradientInstance = function () {\n        if (this.gradient) {\n            var fill = this.fill;\n            if (fill) {\n                var gradient = new LinearGradient();\n                gradient.angle = 270;\n                gradient.stops = [{\n                        offset: 0,\n                        color: Color.fromString(fill).brighter().toString()\n                    }, {\n                        offset: 1,\n                        color: Color.fromString(fill).darker().toString()\n                    }];\n                this.gradientInstance = gradient;\n            }\n        }\n        else {\n            this.gradientInstance = undefined;\n        }\n    };\n    Object.defineProperty(Rect.prototype, \"fill\", {\n        get: function () {\n            return this._fill;\n        },\n        set: function (value) {\n            if (this._fill !== value) {\n                this._fill = value;\n                this.updateGradientInstance();\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"strokeWidth\", {\n        get: function () {\n            return this._strokeWidth;\n        },\n        set: function (value) {\n            if (this._strokeWidth !== value) {\n                this._strokeWidth = value;\n                // Normally, when the `lineWidth` changes, we only need to repaint the rect\n                // without updating the path. If the `isCrisp` is set to `true` however,\n                // we need to update the path to make sure the new stroke aligns to\n                // the pixel grid. This is the reason we override the `lineWidth` setter\n                // and getter here.\n                if (this.crisp || this.sizing === RectSizing.Border) {\n                    this.dirtyPath = true;\n                }\n                else {\n                    this.effectiveStrokeWidth = value;\n                    this.dirty = true;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"sizing\", {\n        get: function () {\n            return this._sizing;\n        },\n        set: function (value) {\n            if (this._sizing !== value) {\n                this._sizing = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Rect.prototype.updatePath = function () {\n        var borderSizing = this.sizing === RectSizing.Border;\n        var path = this.path;\n        path.clear();\n        var x = this.x;\n        var y = this.y;\n        var width = this.width;\n        var height = this.height;\n        var strokeWidth;\n        if (borderSizing) {\n            var halfWidth = width / 2;\n            var halfHeight = height / 2;\n            strokeWidth = Math.min(this.strokeWidth, halfWidth, halfHeight);\n            x = Math.min(x + strokeWidth / 2, x + halfWidth);\n            y = Math.min(y + strokeWidth / 2, y + halfHeight);\n            width = Math.max(width - strokeWidth, 0);\n            height = Math.max(height - strokeWidth, 0);\n        }\n        else {\n            strokeWidth = this.strokeWidth;\n        }\n        this.effectiveStrokeWidth = strokeWidth;\n        if (this.crisp && !borderSizing) {\n            var _a = this, a = _a.alignment, al = _a.align;\n            path.rect(al(a, x), al(a, y), al(a, x, width), al(a, y, height));\n        }\n        else {\n            path.rect(x, y, width, height);\n        }\n    };\n    Rect.prototype.computeBBox = function () {\n        var _a = this, x = _a.x, y = _a.y, width = _a.width, height = _a.height;\n        return new BBox(x, y, width, height);\n    };\n    Rect.prototype.isPointInPath = function (x, y) {\n        var point = this.transformPoint(x, y);\n        var bbox = this.computeBBox();\n        return bbox.containsPoint(point.x, point.y);\n    };\n    Rect.prototype.isPointInStroke = function (x, y) {\n        return false;\n    };\n    Rect.prototype.fillStroke = function (ctx) {\n        if (!this.scene) {\n            return;\n        }\n        var pixelRatio = this.scene.canvas.pixelRatio || 1;\n        if (this.fill) {\n            if (this.gradientInstance) {\n                ctx.fillStyle = this.gradientInstance.generateGradient(ctx, this.computeBBox());\n            }\n            else {\n                ctx.fillStyle = this.fill;\n            }\n            ctx.globalAlpha = this.opacity * this.fillOpacity;\n            // The canvas context scaling (depends on the device's pixel ratio)\n            // has no effect on shadows, so we have to account for the pixel ratio\n            // manually here.\n            var fillShadow = this.fillShadow;\n            if (fillShadow && fillShadow.enabled) {\n                ctx.shadowColor = fillShadow.color;\n                ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n                ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n                ctx.shadowBlur = fillShadow.blur * pixelRatio;\n            }\n            ctx.fill();\n        }\n        ctx.shadowColor = 'rgba(0, 0, 0, 0)';\n        if (this.stroke && this.effectiveStrokeWidth) {\n            ctx.strokeStyle = this.stroke;\n            ctx.globalAlpha = this.opacity * this.strokeOpacity;\n            ctx.lineWidth = this.effectiveStrokeWidth;\n            if (this.lineDash) {\n                ctx.setLineDash(this.lineDash);\n            }\n            if (this.lineDashOffset) {\n                ctx.lineDashOffset = this.lineDashOffset;\n            }\n            if (this.lineCap) {\n                ctx.lineCap = this.lineCap;\n            }\n            if (this.lineJoin) {\n                ctx.lineJoin = this.lineJoin;\n            }\n            var strokeShadow = this.strokeShadow;\n            if (strokeShadow && strokeShadow.enabled) {\n                ctx.shadowColor = strokeShadow.color;\n                ctx.shadowOffsetX = strokeShadow.xOffset * pixelRatio;\n                ctx.shadowOffsetY = strokeShadow.yOffset * pixelRatio;\n                ctx.shadowBlur = strokeShadow.blur * pixelRatio;\n            }\n            ctx.stroke();\n        }\n    };\n    Rect.className = 'Rect';\n    return Rect;\n}(Path));\nexport { Rect };\n"]},"metadata":{},"sourceType":"module"}