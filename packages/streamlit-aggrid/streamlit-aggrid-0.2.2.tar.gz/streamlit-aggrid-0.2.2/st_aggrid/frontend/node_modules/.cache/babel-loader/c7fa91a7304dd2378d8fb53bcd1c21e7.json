{"ast":null,"code":"// Custom `Array.find` implementation for legacy browsers.\nexport function find(arr, predicate) {\n  for (var i = 0; i < arr.length; i++) {\n    var value = arr[i];\n\n    if (predicate(value, i, arr)) {\n      return value;\n    }\n  }\n}\nexport function findIndex(arr, predicate) {\n  for (var i = 0; i < arr.length; i++) {\n    if (predicate(arr[i], i, arr)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n/**\n * Returns the minimum and maximum value in the given iterable using natural order.\n * If the iterable contains no comparable values, returns `undefined`.\n * @param values\n */\n\nexport function extent(values) {\n  var n = values.length;\n  var i = -1;\n  var value;\n  var min;\n  var max;\n\n  while (++i < n) {\n    // Find the first comparable finite value.\n    if ((value = values[i]) != null && value >= value) {\n      min = max = value;\n\n      while (++i < n) {\n        // Compare the remaining values.\n        if ((value = values[i]) != null) {\n          if (min > value) {\n            min = value;\n          }\n\n          if (max < value) {\n            max = value;\n          }\n        }\n      }\n    }\n  }\n\n  return typeof min === 'undefined' || typeof max === 'undefined' ? undefined : [min, max];\n}\nexport function finiteExtent(values) {\n  var n = values.length;\n  var i = -1;\n  var value;\n  var min;\n  var max;\n\n  while (++i < n) {\n    // Find the first comparable finite value.\n    if ((value = values[i]) != null && value >= value && isFinite(value)) {\n      min = max = value;\n\n      while (++i < n) {\n        // Compare the remaining values.\n        if ((value = values[i]) != null && isFinite(value)) {\n          if (min > value) {\n            min = value;\n          }\n\n          if (max < value) {\n            max = value;\n          }\n        }\n      }\n    }\n  }\n\n  return min === undefined || max === undefined ? undefined : [min, max];\n}\n/**\n * This method will only return `undefined` if there's not a single valid finite number present\n * in the given array of values. Date values will be converted to timestamps.\n * @param values\n */\n\nexport function numericExtent(values) {\n  var calculatedExtent = finiteExtent(values);\n\n  if (typeof calculatedExtent === 'undefined') {\n    return;\n  }\n\n  var a = calculatedExtent[0],\n      b = calculatedExtent[1];\n  var min = a instanceof Date ? a.getTime() : a;\n  var max = b instanceof Date ? b.getTime() : b;\n\n  if (typeof min === 'number' && isFinite(min) && typeof max === 'number' && isFinite(max)) {\n    return [min, max];\n  }\n}\n/**\n * finds the min and max using a process appropriate for stacked values. Ie,\n * summing up the positive and negative numbers, and returning the totals of each\n */\n\nexport function findMinMax(values) {\n  var min = 0;\n  var max = 0;\n\n  for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n    var value = values_1[_i];\n\n    if (value < 0) {\n      min += value;\n    } else {\n      max += value;\n    }\n  }\n\n  return {\n    min: min,\n    max: max\n  };\n}\nexport function copy(array, start, count) {\n  if (start === void 0) {\n    start = 0;\n  }\n\n  if (count === void 0) {\n    count = array.length;\n  }\n\n  var result = [];\n  var n = array.length;\n\n  if (n) {\n    for (var i = 0; i < count; i++) {\n      result.push(array[(start + i) % n]);\n    }\n  }\n\n  return result;\n}","map":{"version":3,"sources":["C:/dev/streamlit-aggrid/st_aggrid/frontend/node_modules/ag-charts-community/dist/es6/util/array.js"],"names":["find","arr","predicate","i","length","value","findIndex","extent","values","n","min","max","undefined","finiteExtent","isFinite","numericExtent","calculatedExtent","a","b","Date","getTime","findMinMax","_i","values_1","copy","array","start","count","result","push"],"mappings":"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","sourcesContent":["// Custom `Array.find` implementation for legacy browsers.\nexport function find(arr, predicate) {\n    for (var i = 0; i < arr.length; i++) {\n        var value = arr[i];\n        if (predicate(value, i, arr)) {\n            return value;\n        }\n    }\n}\nexport function findIndex(arr, predicate) {\n    for (var i = 0; i < arr.length; i++) {\n        if (predicate(arr[i], i, arr)) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Returns the minimum and maximum value in the given iterable using natural order.\n * If the iterable contains no comparable values, returns `undefined`.\n * @param values\n */\nexport function extent(values) {\n    var n = values.length;\n    var i = -1;\n    var value;\n    var min;\n    var max;\n    while (++i < n) { // Find the first comparable finite value.\n        if ((value = values[i]) != null && value >= value) {\n            min = max = value;\n            while (++i < n) { // Compare the remaining values.\n                if ((value = values[i]) != null) {\n                    if (min > value) {\n                        min = value;\n                    }\n                    if (max < value) {\n                        max = value;\n                    }\n                }\n            }\n        }\n    }\n    return typeof min === 'undefined' || typeof max === 'undefined' ? undefined : [min, max];\n}\nexport function finiteExtent(values) {\n    var n = values.length;\n    var i = -1;\n    var value;\n    var min;\n    var max;\n    while (++i < n) { // Find the first comparable finite value.\n        if ((value = values[i]) != null && value >= value && isFinite(value)) {\n            min = max = value;\n            while (++i < n) { // Compare the remaining values.\n                if ((value = values[i]) != null && isFinite(value)) {\n                    if (min > value) {\n                        min = value;\n                    }\n                    if (max < value) {\n                        max = value;\n                    }\n                }\n            }\n        }\n    }\n    return min === undefined || max === undefined ? undefined : [min, max];\n}\n/**\n * This method will only return `undefined` if there's not a single valid finite number present\n * in the given array of values. Date values will be converted to timestamps.\n * @param values\n */\nexport function numericExtent(values) {\n    var calculatedExtent = finiteExtent(values);\n    if (typeof calculatedExtent === 'undefined') {\n        return;\n    }\n    var a = calculatedExtent[0], b = calculatedExtent[1];\n    var min = a instanceof Date ? a.getTime() : a;\n    var max = b instanceof Date ? b.getTime() : b;\n    if (typeof min === 'number' && isFinite(min) && typeof max === 'number' && isFinite(max)) {\n        return [min, max];\n    }\n}\n/**\n * finds the min and max using a process appropriate for stacked values. Ie,\n * summing up the positive and negative numbers, and returning the totals of each\n */\nexport function findMinMax(values) {\n    var min = 0;\n    var max = 0;\n    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n        var value = values_1[_i];\n        if (value < 0) {\n            min += value;\n        }\n        else {\n            max += value;\n        }\n    }\n    return { min: min, max: max };\n}\nexport function copy(array, start, count) {\n    if (start === void 0) { start = 0; }\n    if (count === void 0) { count = array.length; }\n    var result = [];\n    var n = array.length;\n    if (n) {\n        for (var i = 0; i < count; i++) {\n            result.push(array[(start + i) % n]);\n        }\n    }\n    return result;\n}\n"]},"metadata":{},"sourceType":"module"}