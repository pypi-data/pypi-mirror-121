{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Bean, BeanStub, PostConstruct, _ } from '@ag-grid-community/core'; // @ts-ignore\n\nvar AGBigInt = typeof BigInt === 'undefined' ? null : BigInt;\n\nvar AggFuncService = function (_super) {\n  __extends(AggFuncService, _super);\n\n  function AggFuncService() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.aggFuncsMap = {};\n    _this.initialised = false;\n    return _this;\n  }\n\n  AggFuncService_1 = AggFuncService;\n\n  AggFuncService.prototype.init = function () {\n    if (this.initialised) {\n      return;\n    }\n\n    this.initialiseWithDefaultAggregations();\n    this.addAggFuncs(this.gridOptionsWrapper.getAggFuncs());\n  };\n\n  AggFuncService.prototype.initialiseWithDefaultAggregations = function () {\n    this.aggFuncsMap[AggFuncService_1.AGG_SUM] = aggSum;\n    this.aggFuncsMap[AggFuncService_1.AGG_FIRST] = aggFirst;\n    this.aggFuncsMap[AggFuncService_1.AGG_LAST] = aggLast;\n    this.aggFuncsMap[AggFuncService_1.AGG_MIN] = aggMin;\n    this.aggFuncsMap[AggFuncService_1.AGG_MAX] = aggMax;\n    this.aggFuncsMap[AggFuncService_1.AGG_COUNT] = aggCount;\n    this.aggFuncsMap[AggFuncService_1.AGG_AVG] = aggAvg;\n    this.initialised = true;\n  };\n\n  AggFuncService.prototype.getDefaultAggFunc = function (column) {\n    var allKeys = this.getFuncNames(column); // use 'sum' if it's a) allowed for the column and b) still registered\n    // (ie not removed by user)\n\n    var sumInKeysList = _.includes(allKeys, AggFuncService_1.AGG_SUM);\n\n    var sumInFuncs = _.exists(this.aggFuncsMap[AggFuncService_1.AGG_SUM]);\n\n    if (sumInKeysList && sumInFuncs) {\n      return AggFuncService_1.AGG_SUM;\n    }\n\n    return _.existsAndNotEmpty(allKeys) ? allKeys[0] : null;\n  };\n\n  AggFuncService.prototype.addAggFuncs = function (aggFuncs) {\n    _.iterateObject(aggFuncs, this.addAggFunc.bind(this));\n  };\n\n  AggFuncService.prototype.addAggFunc = function (key, aggFunc) {\n    this.init();\n    this.aggFuncsMap[key] = aggFunc;\n  };\n\n  AggFuncService.prototype.getAggFunc = function (name) {\n    this.init();\n    return this.aggFuncsMap[name];\n  };\n\n  AggFuncService.prototype.getFuncNames = function (column) {\n    var userAllowedFuncs = column.getColDef().allowedAggFuncs;\n    return userAllowedFuncs == null ? Object.keys(this.aggFuncsMap).sort() : userAllowedFuncs;\n  };\n\n  AggFuncService.prototype.clear = function () {\n    this.aggFuncsMap = {};\n  };\n\n  var AggFuncService_1;\n  AggFuncService.AGG_SUM = 'sum';\n  AggFuncService.AGG_FIRST = 'first';\n  AggFuncService.AGG_LAST = 'last';\n  AggFuncService.AGG_MIN = 'min';\n  AggFuncService.AGG_MAX = 'max';\n  AggFuncService.AGG_COUNT = 'count';\n  AggFuncService.AGG_AVG = 'avg';\n\n  __decorate([PostConstruct], AggFuncService.prototype, \"init\", null);\n\n  AggFuncService = AggFuncService_1 = __decorate([Bean('aggFuncService')], AggFuncService);\n  return AggFuncService;\n}(BeanStub);\n\nexport { AggFuncService };\n\nfunction aggSum(params) {\n  var values = params.values;\n  var result = null; // the logic ensures that we never combine bigint arithmetic with numbers, but TS is hard to please\n  // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n\n  for (var i = 0; i < values.length; i++) {\n    var value = values[i];\n\n    if (typeof value === 'number') {\n      if (result === null) {\n        result = value;\n      } else {\n        if (AGBigInt) {\n          result += typeof result === 'number' ? value : AGBigInt(value);\n        } else {\n          result += value;\n        }\n      }\n    } else if (typeof value === 'bigint') {\n      if (result === null) {\n        result = value;\n      } else {\n        result = (typeof result === 'bigint' ? result : AGBigInt(result)) + value;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction aggFirst(params) {\n  return params.values.length > 0 ? params.values[0] : null;\n}\n\nfunction aggLast(params) {\n  return params.values.length > 0 ? _.last(params.values) : null;\n}\n\nfunction aggMin(params) {\n  var values = params.values;\n  var result = null; // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n\n  for (var i = 0; i < values.length; i++) {\n    var value = values[i];\n\n    if ((typeof value === 'number' || typeof value === 'bigint') && (result === null || result > value)) {\n      result = value;\n    }\n  }\n\n  return result;\n}\n\nfunction aggMax(params) {\n  var values = params.values;\n  var result = null; // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n\n  for (var i = 0; i < values.length; i++) {\n    var value = values[i];\n\n    if ((typeof value === 'number' || typeof value === 'bigint') && (result === null || result < value)) {\n      result = value;\n    }\n  }\n\n  return result;\n}\n\nfunction aggCount(params) {\n  var values = params.values;\n  var result = 0; // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n\n  for (var i = 0; i < values.length; i++) {\n    var value = values[i]; // check if the value is from a group, in which case use the group's count\n\n    result += value != null && typeof value.value === 'number' ? value.value : 1;\n  }\n\n  return {\n    value: result,\n    toString: function toString() {\n      return this.value.toString();\n    },\n    // used for sorting\n    toNumber: function toNumber() {\n      return this.value;\n    }\n  };\n} // the average function is tricky as the multiple levels require weighted averages\n// for the non-leaf node aggregations.\n\n\nfunction aggAvg(params) {\n  var values = params.values;\n  var sum = 0; // the logic ensures that we never combine bigint arithmetic with numbers, but TS is hard to please\n\n  var count = 0; // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n\n  for (var i = 0; i < values.length; i++) {\n    var currentValue = values[i];\n    var valueToAdd = null;\n\n    if (typeof currentValue === 'number' || typeof currentValue === 'bigint') {\n      valueToAdd = currentValue;\n      count++;\n    } else if (currentValue != null && (typeof currentValue.value === 'number' || typeof currentValue.value === 'bigint') && typeof currentValue.count === 'number') {\n      // we are aggregating groups, so we take the aggregated values to calculated a weighted average\n      if (AGBigInt) {\n        valueToAdd = currentValue.value * (typeof currentValue.value === 'number' ? currentValue.count : AGBigInt(currentValue.count));\n      } else {\n        valueToAdd = currentValue.value * currentValue.count;\n      }\n\n      count += currentValue.count;\n    }\n\n    if (typeof valueToAdd === 'number') {\n      if (AGBigInt) {\n        sum += typeof sum === 'number' ? valueToAdd : AGBigInt(valueToAdd);\n      } else {\n        sum += valueToAdd;\n      }\n    } else if (typeof valueToAdd === 'bigint') {\n      sum = (typeof sum === 'bigint' ? sum : AGBigInt(sum)) + valueToAdd;\n    }\n  }\n\n  var value = null; // avoid divide by zero error\n\n  if (count > 0) {\n    if (AGBigInt) {\n      value = sum / (typeof sum === 'number' ? count : AGBigInt(count));\n    } else {\n      value = sum / count;\n    }\n  } // the result will be an object. when this cell is rendered, only the avg is shown.\n  // however when this cell is part of another aggregation, the count is also needed\n  // to create a weighted average for the next level.\n\n\n  return {\n    count: count,\n    value: value,\n    // the grid by default uses toString to render values for an object, so this\n    // is a trick to get the default cellRenderer to display the avg value\n    toString: function toString() {\n      return typeof this.value === 'number' || typeof this.value === 'bigint' ? this.value.toString() : '';\n    },\n    // used for sorting\n    toNumber: function toNumber() {\n      return this.value;\n    }\n  };\n}","map":{"version":3,"sources":["C:/dev/streamlit-aggrid/st_aggrid/frontend/node_modules/@ag-grid-enterprise/row-grouping/dist/es6/rowGrouping/aggFuncService.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","Bean","BeanStub","PostConstruct","_","AGBigInt","BigInt","AggFuncService","_super","_this","apply","aggFuncsMap","initialised","AggFuncService_1","init","initialiseWithDefaultAggregations","addAggFuncs","gridOptionsWrapper","getAggFuncs","AGG_SUM","aggSum","AGG_FIRST","aggFirst","AGG_LAST","aggLast","AGG_MIN","aggMin","AGG_MAX","aggMax","AGG_COUNT","aggCount","AGG_AVG","aggAvg","getDefaultAggFunc","column","allKeys","getFuncNames","sumInKeysList","includes","sumInFuncs","exists","existsAndNotEmpty","aggFuncs","iterateObject","addAggFunc","bind","aggFunc","getAggFunc","name","userAllowedFuncs","getColDef","allowedAggFuncs","keys","sort","clear","params","values","result","value","last","toString","toNumber","sum","count","currentValue","valueToAdd"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Bean, BeanStub, PostConstruct, _ } from '@ag-grid-community/core';\n// @ts-ignore\nvar AGBigInt = typeof BigInt === 'undefined' ? null : BigInt;\nvar AggFuncService = /** @class */ (function (_super) {\n    __extends(AggFuncService, _super);\n    function AggFuncService() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.aggFuncsMap = {};\n        _this.initialised = false;\n        return _this;\n    }\n    AggFuncService_1 = AggFuncService;\n    AggFuncService.prototype.init = function () {\n        if (this.initialised) {\n            return;\n        }\n        this.initialiseWithDefaultAggregations();\n        this.addAggFuncs(this.gridOptionsWrapper.getAggFuncs());\n    };\n    AggFuncService.prototype.initialiseWithDefaultAggregations = function () {\n        this.aggFuncsMap[AggFuncService_1.AGG_SUM] = aggSum;\n        this.aggFuncsMap[AggFuncService_1.AGG_FIRST] = aggFirst;\n        this.aggFuncsMap[AggFuncService_1.AGG_LAST] = aggLast;\n        this.aggFuncsMap[AggFuncService_1.AGG_MIN] = aggMin;\n        this.aggFuncsMap[AggFuncService_1.AGG_MAX] = aggMax;\n        this.aggFuncsMap[AggFuncService_1.AGG_COUNT] = aggCount;\n        this.aggFuncsMap[AggFuncService_1.AGG_AVG] = aggAvg;\n        this.initialised = true;\n    };\n    AggFuncService.prototype.getDefaultAggFunc = function (column) {\n        var allKeys = this.getFuncNames(column);\n        // use 'sum' if it's a) allowed for the column and b) still registered\n        // (ie not removed by user)\n        var sumInKeysList = _.includes(allKeys, AggFuncService_1.AGG_SUM);\n        var sumInFuncs = _.exists(this.aggFuncsMap[AggFuncService_1.AGG_SUM]);\n        if (sumInKeysList && sumInFuncs) {\n            return AggFuncService_1.AGG_SUM;\n        }\n        return _.existsAndNotEmpty(allKeys) ? allKeys[0] : null;\n    };\n    AggFuncService.prototype.addAggFuncs = function (aggFuncs) {\n        _.iterateObject(aggFuncs, this.addAggFunc.bind(this));\n    };\n    AggFuncService.prototype.addAggFunc = function (key, aggFunc) {\n        this.init();\n        this.aggFuncsMap[key] = aggFunc;\n    };\n    AggFuncService.prototype.getAggFunc = function (name) {\n        this.init();\n        return this.aggFuncsMap[name];\n    };\n    AggFuncService.prototype.getFuncNames = function (column) {\n        var userAllowedFuncs = column.getColDef().allowedAggFuncs;\n        return userAllowedFuncs == null ? Object.keys(this.aggFuncsMap).sort() : userAllowedFuncs;\n    };\n    AggFuncService.prototype.clear = function () {\n        this.aggFuncsMap = {};\n    };\n    var AggFuncService_1;\n    AggFuncService.AGG_SUM = 'sum';\n    AggFuncService.AGG_FIRST = 'first';\n    AggFuncService.AGG_LAST = 'last';\n    AggFuncService.AGG_MIN = 'min';\n    AggFuncService.AGG_MAX = 'max';\n    AggFuncService.AGG_COUNT = 'count';\n    AggFuncService.AGG_AVG = 'avg';\n    __decorate([\n        PostConstruct\n    ], AggFuncService.prototype, \"init\", null);\n    AggFuncService = AggFuncService_1 = __decorate([\n        Bean('aggFuncService')\n    ], AggFuncService);\n    return AggFuncService;\n}(BeanStub));\nexport { AggFuncService };\nfunction aggSum(params) {\n    var values = params.values;\n    var result = null; // the logic ensures that we never combine bigint arithmetic with numbers, but TS is hard to please\n    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n    for (var i = 0; i < values.length; i++) {\n        var value = values[i];\n        if (typeof value === 'number') {\n            if (result === null) {\n                result = value;\n            }\n            else {\n                if (AGBigInt) {\n                    result += typeof result === 'number' ? value : AGBigInt(value);\n                }\n                else {\n                    result += value;\n                }\n            }\n        }\n        else if (typeof value === 'bigint') {\n            if (result === null) {\n                result = value;\n            }\n            else {\n                result = (typeof result === 'bigint' ? result : AGBigInt(result)) + value;\n            }\n        }\n    }\n    return result;\n}\nfunction aggFirst(params) {\n    return params.values.length > 0 ? params.values[0] : null;\n}\nfunction aggLast(params) {\n    return params.values.length > 0 ? _.last(params.values) : null;\n}\nfunction aggMin(params) {\n    var values = params.values;\n    var result = null;\n    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n    for (var i = 0; i < values.length; i++) {\n        var value = values[i];\n        if ((typeof value === 'number' || typeof value === 'bigint') && (result === null || result > value)) {\n            result = value;\n        }\n    }\n    return result;\n}\nfunction aggMax(params) {\n    var values = params.values;\n    var result = null;\n    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n    for (var i = 0; i < values.length; i++) {\n        var value = values[i];\n        if ((typeof value === 'number' || typeof value === 'bigint') && (result === null || result < value)) {\n            result = value;\n        }\n    }\n    return result;\n}\nfunction aggCount(params) {\n    var values = params.values;\n    var result = 0;\n    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n    for (var i = 0; i < values.length; i++) {\n        var value = values[i];\n        // check if the value is from a group, in which case use the group's count\n        result += value != null && typeof value.value === 'number' ? value.value : 1;\n    }\n    return {\n        value: result,\n        toString: function () {\n            return this.value.toString();\n        },\n        // used for sorting\n        toNumber: function () {\n            return this.value;\n        }\n    };\n}\n// the average function is tricky as the multiple levels require weighted averages\n// for the non-leaf node aggregations.\nfunction aggAvg(params) {\n    var values = params.values;\n    var sum = 0; // the logic ensures that we never combine bigint arithmetic with numbers, but TS is hard to please\n    var count = 0;\n    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n    for (var i = 0; i < values.length; i++) {\n        var currentValue = values[i];\n        var valueToAdd = null;\n        if (typeof currentValue === 'number' || typeof currentValue === 'bigint') {\n            valueToAdd = currentValue;\n            count++;\n        }\n        else if (currentValue != null && (typeof currentValue.value === 'number' || typeof currentValue.value === 'bigint') && typeof currentValue.count === 'number') {\n            // we are aggregating groups, so we take the aggregated values to calculated a weighted average\n            if (AGBigInt) {\n                valueToAdd = currentValue.value * (typeof currentValue.value === 'number' ? currentValue.count : AGBigInt(currentValue.count));\n            }\n            else {\n                valueToAdd = currentValue.value * currentValue.count;\n            }\n            count += currentValue.count;\n        }\n        if (typeof valueToAdd === 'number') {\n            if (AGBigInt) {\n                sum += typeof sum === 'number' ? valueToAdd : AGBigInt(valueToAdd);\n            }\n            else {\n                sum += valueToAdd;\n            }\n        }\n        else if (typeof valueToAdd === 'bigint') {\n            sum = (typeof sum === 'bigint' ? sum : AGBigInt(sum)) + valueToAdd;\n        }\n    }\n    var value = null;\n    // avoid divide by zero error\n    if (count > 0) {\n        if (AGBigInt) {\n            value = sum / (typeof sum === 'number' ? count : AGBigInt(count));\n        }\n        else {\n            value = sum / count;\n        }\n    }\n    // the result will be an object. when this cell is rendered, only the avg is shown.\n    // however when this cell is part of another aggregation, the count is also needed\n    // to create a weighted average for the next level.\n    return {\n        count: count,\n        value: value,\n        // the grid by default uses toString to render values for an object, so this\n        // is a trick to get the default cellRenderer to display the avg value\n        toString: function () {\n            return typeof this.value === 'number' || typeof this.value === 'bigint' ? this.value.toString() : '';\n        },\n        // used for sorting\n        toNumber: function () {\n            return this.value;\n        }\n    };\n}\n"]},"metadata":{},"sourceType":"module"}