{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { _, Autowired, BeanStub, ModuleNames, ModuleRegistry, Optional } from \"@ag-grid-community/core\";\nimport { ChartDataModel } from \"./chartDataModel\";\n\nvar ChartDatasource = function (_super) {\n  __extends(ChartDatasource, _super);\n\n  function ChartDatasource() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ChartDatasource.prototype.getData = function (params) {\n    if (params.crossFiltering) {\n      if (params.grouping) {\n        console.warn(\"ag-grid: crossing filtering with row grouping is not supported.\");\n        return {\n          data: [],\n          columnNames: {}\n        };\n      }\n\n      if (!this.gridOptionsWrapper.isRowModelDefault()) {\n        console.warn(\"ag-grid: crossing filtering is only supported in the client side row model.\");\n        return {\n          data: [],\n          columnNames: {}\n        };\n      }\n    }\n\n    var isServerSide = this.gridOptionsWrapper.isRowModelServerSide();\n\n    if (isServerSide && params.pivoting) {\n      this.updatePivotKeysForSSRM();\n    }\n\n    var result = this.extractRowsFromGridRowModel(params);\n    result.data = this.aggregateRowsByDimension(params, result.data);\n    return result;\n  };\n\n  ChartDatasource.prototype.extractRowsFromGridRowModel = function (params) {\n    var _this = this;\n\n    var extractedRowData = [];\n    var columnNames = {}; // maps used to keep track of expanded groups that need to be removed\n\n    var groupNodeIndexes = {};\n    var groupsToRemove = {}; // only used when cross filtering\n\n    var filteredNodes = {};\n    var allRowNodes = [];\n    var numRows;\n\n    if (params.crossFiltering) {\n      filteredNodes = this.getFilteredRowNodes();\n      allRowNodes = this.getAllRowNodes();\n      numRows = allRowNodes.length;\n    } else {\n      // make sure enough rows in range to chart. if user filters and less rows, then end row will be\n      // the last displayed row, not where the range ends.\n      var modelLastRow = this.gridRowModel.getRowCount() - 1;\n      var rangeLastRow = params.endRow >= 0 ? Math.min(params.endRow, modelLastRow) : modelLastRow;\n      numRows = rangeLastRow - params.startRow + 1;\n    }\n\n    var _loop_1 = function _loop_1(i) {\n      var data = {};\n      var rowNode = params.crossFiltering ? allRowNodes[i] : this_1.gridRowModel.getRow(i + params.startRow); // first get data for dimensions columns\n\n      params.dimensionCols.forEach(function (col) {\n        var colId = col.colId;\n\n        var column = _this.columnModel.getGridColumn(colId);\n\n        if (column) {\n          var valueObject = _this.valueService.getValue(column, rowNode); // when grouping we also need to build up multi category labels for charts\n\n\n          if (params.grouping) {\n            var valueString = valueObject && valueObject.toString ? String(valueObject.toString()) : ''; // traverse parents to extract group label path\n\n            var labels = ChartDatasource.getGroupLabels(rowNode, valueString);\n            data[colId] = {\n              labels: labels,\n              toString: function toString() {\n                return this.labels.filter(function (l) {\n                  return !!l;\n                }).reverse().join(' - ');\n              }\n            }; // keep track of group node indexes so they can be padded when other groups are expanded\n\n            if (rowNode.group) {\n              groupNodeIndexes[labels.toString()] = i;\n            } // if node (group or leaf) has parents then it is expanded and should be removed\n\n\n            var groupKey = labels.slice(1, labels.length).toString();\n\n            if (groupKey) {\n              groupsToRemove[groupKey] = groupNodeIndexes[groupKey];\n            }\n          } else {\n            // leaf nodes can be directly added to dimension columns\n            data[colId] = valueObject;\n          }\n        } else {\n          // introduce a default category when no dimensions exist with a value based off row index (+1)\n          data[ChartDataModel.DEFAULT_CATEGORY] = i + 1;\n        }\n      }); // then get data for value columns\n\n      params.valueCols.forEach(function (col) {\n        var columnNamesArr = []; // pivot keys should be added first\n\n        var pivotKeys = col.getColDef().pivotKeys;\n\n        if (pivotKeys) {\n          columnNamesArr = pivotKeys.slice();\n        } // then add column header name to results\n\n\n        var headerName = col.getColDef().headerName;\n\n        if (headerName) {\n          columnNamesArr.push(headerName);\n        } // add array of column names to results\n\n\n        if (columnNamesArr.length > 0) {\n          columnNames[col.getId()] = columnNamesArr;\n        }\n\n        var colId = col.getColId();\n\n        if (params.crossFiltering) {\n          var filteredOutColId = colId + '-filtered-out'; // add data value to value column\n\n          var value = _this.valueService.getValue(col, rowNode);\n\n          var actualValue = value != null && typeof value.toNumber === 'function' ? value.toNumber() : value;\n\n          if (filteredNodes[rowNode.id]) {\n            data[colId] = actualValue;\n            data[filteredOutColId] = params.aggFunc || params.isScatter ? undefined : 0;\n          } else {\n            data[colId] = params.aggFunc || params.isScatter ? undefined : 0;\n            data[filteredOutColId] = actualValue;\n          }\n        } else {\n          // add data value to value column\n          var value = _this.valueService.getValue(col, rowNode);\n\n          data[colId] = value != null && typeof value.toNumber === 'function' ? value.toNumber() : value;\n        }\n      }); // add data to results\n\n      extractedRowData.push(data);\n    };\n\n    var this_1 = this;\n\n    for (var i = 0; i < numRows; i++) {\n      _loop_1(i);\n    }\n\n    if (params.grouping) {\n      var groupIndexesToRemove_1 = _.values(groupsToRemove);\n\n      extractedRowData = extractedRowData.filter(function (_1, index) {\n        return !_.includes(groupIndexesToRemove_1, index);\n      });\n    }\n\n    return {\n      data: extractedRowData,\n      columnNames: columnNames\n    };\n  };\n\n  ChartDatasource.prototype.aggregateRowsByDimension = function (params, dataFromGrid) {\n    var _this = this;\n\n    var dimensionCols = params.dimensionCols;\n\n    if (!params.aggFunc || dimensionCols.length === 0) {\n      return dataFromGrid;\n    }\n\n    var lastCol = _.last(dimensionCols);\n\n    var lastColId = lastCol && lastCol.colId;\n    var map = {};\n    var dataAggregated = [];\n    dataFromGrid.forEach(function (data) {\n      var currentMap = map;\n      dimensionCols.forEach(function (col) {\n        var colId = col.colId;\n        var key = data[colId];\n\n        if (colId === lastColId) {\n          var groupItem_1 = currentMap[key];\n\n          if (!groupItem_1) {\n            groupItem_1 = {\n              __children: []\n            };\n            dimensionCols.forEach(function (dimCol) {\n              var dimColId = dimCol.colId;\n              groupItem_1[dimColId] = data[dimColId];\n            });\n            currentMap[key] = groupItem_1;\n            dataAggregated.push(groupItem_1);\n          }\n\n          groupItem_1.__children.push(data);\n        } else {\n          // map of maps\n          if (!currentMap[key]) {\n            currentMap[key] = {};\n          }\n\n          currentMap = currentMap[key];\n        }\n      });\n    });\n\n    if (ModuleRegistry.assertRegistered(ModuleNames.RowGroupingModule, 'Charting Aggregation')) {\n      dataAggregated.forEach(function (groupItem) {\n        return params.valueCols.forEach(function (col) {\n          if (params.crossFiltering) {\n            params.valueCols.forEach(function (valueCol) {\n              // filtered data\n              var dataToAgg = groupItem.__children.filter(function (child) {\n                return typeof child[valueCol.getColId()] !== 'undefined';\n              }).map(function (child) {\n                return child[valueCol.getColId()];\n              });\n\n              var aggResult = _this.aggregationStage.aggregateValues(dataToAgg, params.aggFunc);\n\n              groupItem[valueCol.getId()] = aggResult && typeof aggResult.value !== 'undefined' ? aggResult.value : aggResult; // filtered out data\n\n              var filteredOutColId = valueCol.getId() + '-filtered-out';\n\n              var dataToAggFiltered = groupItem.__children.filter(function (child) {\n                return typeof child[filteredOutColId] !== 'undefined';\n              }).map(function (child) {\n                return child[filteredOutColId];\n              });\n\n              var aggResultFiltered = _this.aggregationStage.aggregateValues(dataToAggFiltered, params.aggFunc);\n\n              groupItem[filteredOutColId] = aggResultFiltered && typeof aggResultFiltered.value !== 'undefined' ? aggResultFiltered.value : aggResultFiltered;\n            });\n          } else {\n            var dataToAgg = groupItem.__children.map(function (child) {\n              return child[col.getId()];\n            });\n\n            var aggResult = 0;\n\n            if (ModuleRegistry.assertRegistered(ModuleNames.RowGroupingModule, 'Charting Aggregation')) {\n              aggResult = _this.aggregationStage.aggregateValues(dataToAgg, params.aggFunc);\n            }\n\n            groupItem[col.getId()] = aggResult && typeof aggResult.value !== 'undefined' ? aggResult.value : aggResult;\n          }\n        });\n      });\n    }\n\n    return dataAggregated;\n  };\n\n  ChartDatasource.prototype.updatePivotKeysForSSRM = function () {\n    var secondaryColumns = this.columnModel.getSecondaryColumns();\n\n    if (!secondaryColumns) {\n      return;\n    } // we don't know what the application will use for the pivot key separator (i.e. '_' or '|' ) as the\n    // secondary columns are provided to grid by the application via columnApi.setSecondaryColumns()\n\n\n    var pivotKeySeparator = this.extractPivotKeySeparator(secondaryColumns); // 'pivotKeys' is not used by the SSRM for pivoting so it is safe to reuse this colDef property, this way\n    // the same logic can be used for CSRM and SSRM to extract legend names in extractRowsFromGridRowModel()\n\n    secondaryColumns.forEach(function (col) {\n      var keys = col.getColId().split(pivotKeySeparator);\n      col.getColDef().pivotKeys = keys.slice(0, keys.length - 1);\n    });\n  };\n\n  ChartDatasource.prototype.extractPivotKeySeparator = function (secondaryColumns) {\n    if (secondaryColumns.length === 0) {\n      return \"\";\n    }\n\n    var extractSeparator = function extractSeparator(columnGroup, childId) {\n      var groupId = columnGroup.getGroupId();\n\n      if (!columnGroup.getParent()) {\n        // removing groupId ('2000') from childId ('2000|Swimming') yields '|Swimming' so first char is separator\n        return childId.split(groupId)[1][0];\n      }\n\n      return extractSeparator(columnGroup.getParent(), groupId);\n    };\n\n    var firstSecondaryCol = secondaryColumns[0];\n    return extractSeparator(firstSecondaryCol.getParent(), firstSecondaryCol.getColId());\n  };\n\n  ChartDatasource.getGroupLabels = function (rowNode, initialLabel) {\n    var labels = [initialLabel];\n\n    while (rowNode && rowNode.level !== 0) {\n      rowNode = rowNode.parent;\n\n      if (rowNode) {\n        labels.push(rowNode.key);\n      }\n    }\n\n    return labels;\n  };\n\n  ChartDatasource.prototype.getFilteredRowNodes = function () {\n    var filteredNodes = {};\n    this.gridRowModel.forEachNodeAfterFilterAndSort(function (rowNode) {\n      filteredNodes[rowNode.id] = rowNode;\n    });\n    return filteredNodes;\n  };\n\n  ChartDatasource.prototype.getAllRowNodes = function () {\n    var allRowNodes = [];\n    this.gridRowModel.forEachNode(function (rowNode) {\n      allRowNodes.push(rowNode);\n    });\n    return this.sortRowNodes(allRowNodes);\n  };\n\n  ChartDatasource.prototype.sortRowNodes = function (rowNodes) {\n    var sortOptions = this.sortController.getSortOptions();\n    var noSort = !sortOptions || sortOptions.length == 0;\n    if (noSort) return rowNodes;\n    return this.rowNodeSorter.doFullSort(rowNodes, sortOptions);\n  };\n\n  __decorate([Autowired('rowModel')], ChartDatasource.prototype, \"gridRowModel\", void 0);\n\n  __decorate([Autowired('valueService')], ChartDatasource.prototype, \"valueService\", void 0);\n\n  __decorate([Autowired('columnModel')], ChartDatasource.prototype, \"columnModel\", void 0);\n\n  __decorate([Autowired('rowNodeSorter')], ChartDatasource.prototype, \"rowNodeSorter\", void 0);\n\n  __decorate([Autowired('sortController')], ChartDatasource.prototype, \"sortController\", void 0);\n\n  __decorate([Optional('aggregationStage')], ChartDatasource.prototype, \"aggregationStage\", void 0);\n\n  return ChartDatasource;\n}(BeanStub);\n\nexport { ChartDatasource };","map":{"version":3,"sources":["C:/dev/streamlit-aggrid/st_aggrid/frontend/node_modules/@ag-grid-enterprise/charts/dist/es6/charts/chartComp/chartDatasource.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","_","Autowired","BeanStub","ModuleNames","ModuleRegistry","Optional","ChartDataModel","ChartDatasource","_super","apply","getData","params","crossFiltering","grouping","console","warn","data","columnNames","gridOptionsWrapper","isRowModelDefault","isServerSide","isRowModelServerSide","pivoting","updatePivotKeysForSSRM","result","extractRowsFromGridRowModel","aggregateRowsByDimension","_this","extractedRowData","groupNodeIndexes","groupsToRemove","filteredNodes","allRowNodes","numRows","getFilteredRowNodes","getAllRowNodes","modelLastRow","gridRowModel","getRowCount","rangeLastRow","endRow","Math","min","startRow","_loop_1","rowNode","this_1","getRow","dimensionCols","forEach","col","colId","column","columnModel","getGridColumn","valueObject","valueService","getValue","valueString","toString","String","labels","getGroupLabels","filter","l","reverse","join","group","groupKey","slice","DEFAULT_CATEGORY","valueCols","columnNamesArr","pivotKeys","getColDef","headerName","push","getId","getColId","filteredOutColId","value","actualValue","toNumber","id","aggFunc","isScatter","undefined","groupIndexesToRemove_1","values","_1","index","includes","dataFromGrid","lastCol","last","lastColId","map","dataAggregated","currentMap","groupItem_1","__children","dimCol","dimColId","assertRegistered","RowGroupingModule","groupItem","valueCol","dataToAgg","child","aggResult","aggregationStage","aggregateValues","dataToAggFiltered","aggResultFiltered","secondaryColumns","getSecondaryColumns","pivotKeySeparator","extractPivotKeySeparator","keys","split","extractSeparator","columnGroup","childId","groupId","getGroupId","getParent","firstSecondaryCol","initialLabel","level","parent","forEachNodeAfterFilterAndSort","forEachNode","sortRowNodes","rowNodes","sortOptions","sortController","getSortOptions","noSort","rowNodeSorter","doFullSort"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { _, Autowired, BeanStub, ModuleNames, ModuleRegistry, Optional, } from \"@ag-grid-community/core\";\nimport { ChartDataModel } from \"./chartDataModel\";\nvar ChartDatasource = /** @class */ (function (_super) {\n    __extends(ChartDatasource, _super);\n    function ChartDatasource() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ChartDatasource.prototype.getData = function (params) {\n        if (params.crossFiltering) {\n            if (params.grouping) {\n                console.warn(\"ag-grid: crossing filtering with row grouping is not supported.\");\n                return { data: [], columnNames: {} };\n            }\n            if (!this.gridOptionsWrapper.isRowModelDefault()) {\n                console.warn(\"ag-grid: crossing filtering is only supported in the client side row model.\");\n                return { data: [], columnNames: {} };\n            }\n        }\n        var isServerSide = this.gridOptionsWrapper.isRowModelServerSide();\n        if (isServerSide && params.pivoting) {\n            this.updatePivotKeysForSSRM();\n        }\n        var result = this.extractRowsFromGridRowModel(params);\n        result.data = this.aggregateRowsByDimension(params, result.data);\n        return result;\n    };\n    ChartDatasource.prototype.extractRowsFromGridRowModel = function (params) {\n        var _this = this;\n        var extractedRowData = [];\n        var columnNames = {};\n        // maps used to keep track of expanded groups that need to be removed\n        var groupNodeIndexes = {};\n        var groupsToRemove = {};\n        // only used when cross filtering\n        var filteredNodes = {};\n        var allRowNodes = [];\n        var numRows;\n        if (params.crossFiltering) {\n            filteredNodes = this.getFilteredRowNodes();\n            allRowNodes = this.getAllRowNodes();\n            numRows = allRowNodes.length;\n        }\n        else {\n            // make sure enough rows in range to chart. if user filters and less rows, then end row will be\n            // the last displayed row, not where the range ends.\n            var modelLastRow = this.gridRowModel.getRowCount() - 1;\n            var rangeLastRow = params.endRow >= 0 ? Math.min(params.endRow, modelLastRow) : modelLastRow;\n            numRows = rangeLastRow - params.startRow + 1;\n        }\n        var _loop_1 = function (i) {\n            var data = {};\n            var rowNode = params.crossFiltering ? allRowNodes[i] : this_1.gridRowModel.getRow(i + params.startRow);\n            // first get data for dimensions columns\n            params.dimensionCols.forEach(function (col) {\n                var colId = col.colId;\n                var column = _this.columnModel.getGridColumn(colId);\n                if (column) {\n                    var valueObject = _this.valueService.getValue(column, rowNode);\n                    // when grouping we also need to build up multi category labels for charts\n                    if (params.grouping) {\n                        var valueString = valueObject && valueObject.toString ? String(valueObject.toString()) : '';\n                        // traverse parents to extract group label path\n                        var labels = ChartDatasource.getGroupLabels(rowNode, valueString);\n                        data[colId] = {\n                            labels: labels, toString: function () {\n                                return this.labels.filter(function (l) { return !!l; }).reverse().join(' - ');\n                            }\n                        };\n                        // keep track of group node indexes so they can be padded when other groups are expanded\n                        if (rowNode.group) {\n                            groupNodeIndexes[labels.toString()] = i;\n                        }\n                        // if node (group or leaf) has parents then it is expanded and should be removed\n                        var groupKey = labels.slice(1, labels.length).toString();\n                        if (groupKey) {\n                            groupsToRemove[groupKey] = groupNodeIndexes[groupKey];\n                        }\n                    }\n                    else {\n                        // leaf nodes can be directly added to dimension columns\n                        data[colId] = valueObject;\n                    }\n                }\n                else {\n                    // introduce a default category when no dimensions exist with a value based off row index (+1)\n                    data[ChartDataModel.DEFAULT_CATEGORY] = i + 1;\n                }\n            });\n            // then get data for value columns\n            params.valueCols.forEach(function (col) {\n                var columnNamesArr = [];\n                // pivot keys should be added first\n                var pivotKeys = col.getColDef().pivotKeys;\n                if (pivotKeys) {\n                    columnNamesArr = pivotKeys.slice();\n                }\n                // then add column header name to results\n                var headerName = col.getColDef().headerName;\n                if (headerName) {\n                    columnNamesArr.push(headerName);\n                }\n                // add array of column names to results\n                if (columnNamesArr.length > 0) {\n                    columnNames[col.getId()] = columnNamesArr;\n                }\n                var colId = col.getColId();\n                if (params.crossFiltering) {\n                    var filteredOutColId = colId + '-filtered-out';\n                    // add data value to value column\n                    var value = _this.valueService.getValue(col, rowNode);\n                    var actualValue = value != null && typeof value.toNumber === 'function' ? value.toNumber() : value;\n                    if (filteredNodes[rowNode.id]) {\n                        data[colId] = actualValue;\n                        data[filteredOutColId] = params.aggFunc || params.isScatter ? undefined : 0;\n                    }\n                    else {\n                        data[colId] = params.aggFunc || params.isScatter ? undefined : 0;\n                        data[filteredOutColId] = actualValue;\n                    }\n                }\n                else {\n                    // add data value to value column\n                    var value = _this.valueService.getValue(col, rowNode);\n                    data[colId] = value != null && typeof value.toNumber === 'function' ? value.toNumber() : value;\n                }\n            });\n            // add data to results\n            extractedRowData.push(data);\n        };\n        var this_1 = this;\n        for (var i = 0; i < numRows; i++) {\n            _loop_1(i);\n        }\n        if (params.grouping) {\n            var groupIndexesToRemove_1 = _.values(groupsToRemove);\n            extractedRowData = extractedRowData.filter(function (_1, index) { return !_.includes(groupIndexesToRemove_1, index); });\n        }\n        return { data: extractedRowData, columnNames: columnNames };\n    };\n    ChartDatasource.prototype.aggregateRowsByDimension = function (params, dataFromGrid) {\n        var _this = this;\n        var dimensionCols = params.dimensionCols;\n        if (!params.aggFunc || dimensionCols.length === 0) {\n            return dataFromGrid;\n        }\n        var lastCol = _.last(dimensionCols);\n        var lastColId = lastCol && lastCol.colId;\n        var map = {};\n        var dataAggregated = [];\n        dataFromGrid.forEach(function (data) {\n            var currentMap = map;\n            dimensionCols.forEach(function (col) {\n                var colId = col.colId;\n                var key = data[colId];\n                if (colId === lastColId) {\n                    var groupItem_1 = currentMap[key];\n                    if (!groupItem_1) {\n                        groupItem_1 = { __children: [] };\n                        dimensionCols.forEach(function (dimCol) {\n                            var dimColId = dimCol.colId;\n                            groupItem_1[dimColId] = data[dimColId];\n                        });\n                        currentMap[key] = groupItem_1;\n                        dataAggregated.push(groupItem_1);\n                    }\n                    groupItem_1.__children.push(data);\n                }\n                else {\n                    // map of maps\n                    if (!currentMap[key]) {\n                        currentMap[key] = {};\n                    }\n                    currentMap = currentMap[key];\n                }\n            });\n        });\n        if (ModuleRegistry.assertRegistered(ModuleNames.RowGroupingModule, 'Charting Aggregation')) {\n            dataAggregated.forEach(function (groupItem) { return params.valueCols.forEach(function (col) {\n                if (params.crossFiltering) {\n                    params.valueCols.forEach(function (valueCol) {\n                        // filtered data\n                        var dataToAgg = groupItem.__children\n                            .filter(function (child) { return typeof child[valueCol.getColId()] !== 'undefined'; })\n                            .map(function (child) { return child[valueCol.getColId()]; });\n                        var aggResult = _this.aggregationStage.aggregateValues(dataToAgg, params.aggFunc);\n                        groupItem[valueCol.getId()] = aggResult && typeof aggResult.value !== 'undefined' ? aggResult.value : aggResult;\n                        // filtered out data\n                        var filteredOutColId = valueCol.getId() + '-filtered-out';\n                        var dataToAggFiltered = groupItem.__children\n                            .filter(function (child) { return typeof child[filteredOutColId] !== 'undefined'; })\n                            .map(function (child) { return child[filteredOutColId]; });\n                        var aggResultFiltered = _this.aggregationStage.aggregateValues(dataToAggFiltered, params.aggFunc);\n                        groupItem[filteredOutColId] = aggResultFiltered && typeof aggResultFiltered.value !== 'undefined' ? aggResultFiltered.value : aggResultFiltered;\n                    });\n                }\n                else {\n                    var dataToAgg = groupItem.__children.map(function (child) { return child[col.getId()]; });\n                    var aggResult = 0;\n                    if (ModuleRegistry.assertRegistered(ModuleNames.RowGroupingModule, 'Charting Aggregation')) {\n                        aggResult = _this.aggregationStage.aggregateValues(dataToAgg, params.aggFunc);\n                    }\n                    groupItem[col.getId()] = aggResult && typeof aggResult.value !== 'undefined' ? aggResult.value : aggResult;\n                }\n            }); });\n        }\n        return dataAggregated;\n    };\n    ChartDatasource.prototype.updatePivotKeysForSSRM = function () {\n        var secondaryColumns = this.columnModel.getSecondaryColumns();\n        if (!secondaryColumns) {\n            return;\n        }\n        // we don't know what the application will use for the pivot key separator (i.e. '_' or '|' ) as the\n        // secondary columns are provided to grid by the application via columnApi.setSecondaryColumns()\n        var pivotKeySeparator = this.extractPivotKeySeparator(secondaryColumns);\n        // 'pivotKeys' is not used by the SSRM for pivoting so it is safe to reuse this colDef property, this way\n        // the same logic can be used for CSRM and SSRM to extract legend names in extractRowsFromGridRowModel()\n        secondaryColumns.forEach(function (col) {\n            var keys = col.getColId().split(pivotKeySeparator);\n            col.getColDef().pivotKeys = keys.slice(0, keys.length - 1);\n        });\n    };\n    ChartDatasource.prototype.extractPivotKeySeparator = function (secondaryColumns) {\n        if (secondaryColumns.length === 0) {\n            return \"\";\n        }\n        var extractSeparator = function (columnGroup, childId) {\n            var groupId = columnGroup.getGroupId();\n            if (!columnGroup.getParent()) {\n                // removing groupId ('2000') from childId ('2000|Swimming') yields '|Swimming' so first char is separator\n                return childId.split(groupId)[1][0];\n            }\n            return extractSeparator(columnGroup.getParent(), groupId);\n        };\n        var firstSecondaryCol = secondaryColumns[0];\n        return extractSeparator(firstSecondaryCol.getParent(), firstSecondaryCol.getColId());\n    };\n    ChartDatasource.getGroupLabels = function (rowNode, initialLabel) {\n        var labels = [initialLabel];\n        while (rowNode && rowNode.level !== 0) {\n            rowNode = rowNode.parent;\n            if (rowNode) {\n                labels.push(rowNode.key);\n            }\n        }\n        return labels;\n    };\n    ChartDatasource.prototype.getFilteredRowNodes = function () {\n        var filteredNodes = {};\n        this.gridRowModel.forEachNodeAfterFilterAndSort(function (rowNode) {\n            filteredNodes[rowNode.id] = rowNode;\n        });\n        return filteredNodes;\n    };\n    ChartDatasource.prototype.getAllRowNodes = function () {\n        var allRowNodes = [];\n        this.gridRowModel.forEachNode(function (rowNode) {\n            allRowNodes.push(rowNode);\n        });\n        return this.sortRowNodes(allRowNodes);\n    };\n    ChartDatasource.prototype.sortRowNodes = function (rowNodes) {\n        var sortOptions = this.sortController.getSortOptions();\n        var noSort = !sortOptions || sortOptions.length == 0;\n        if (noSort)\n            return rowNodes;\n        return this.rowNodeSorter.doFullSort(rowNodes, sortOptions);\n    };\n    __decorate([\n        Autowired('rowModel')\n    ], ChartDatasource.prototype, \"gridRowModel\", void 0);\n    __decorate([\n        Autowired('valueService')\n    ], ChartDatasource.prototype, \"valueService\", void 0);\n    __decorate([\n        Autowired('columnModel')\n    ], ChartDatasource.prototype, \"columnModel\", void 0);\n    __decorate([\n        Autowired('rowNodeSorter')\n    ], ChartDatasource.prototype, \"rowNodeSorter\", void 0);\n    __decorate([\n        Autowired('sortController')\n    ], ChartDatasource.prototype, \"sortController\", void 0);\n    __decorate([\n        Optional('aggregationStage')\n    ], ChartDatasource.prototype, \"aggregationStage\", void 0);\n    return ChartDatasource;\n}(BeanStub));\nexport { ChartDatasource };\n"]},"metadata":{},"sourceType":"module"}