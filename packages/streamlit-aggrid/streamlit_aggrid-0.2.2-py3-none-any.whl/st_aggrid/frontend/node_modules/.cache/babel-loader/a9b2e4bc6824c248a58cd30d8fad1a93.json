{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { _, Autowired, Bean, BeanStub, OriginalColumnGroup } from \"@ag-grid-community/core\";\n\nvar ToolPanelColDefService = function (_super) {\n  __extends(ToolPanelColDefService, _super);\n\n  function ToolPanelColDefService() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.isColGroupDef = function (colDef) {\n      return colDef && typeof colDef.children !== 'undefined';\n    };\n\n    _this.getId = function (colDef) {\n      return _this.isColGroupDef(colDef) ? colDef.groupId : colDef.colId;\n    };\n\n    return _this;\n  }\n\n  ToolPanelColDefService.prototype.createColumnTree = function (colDefs) {\n    var _this = this;\n\n    var invalidColIds = [];\n\n    var createDummyColGroup = function createDummyColGroup(abstractColDef, depth) {\n      if (_this.isColGroupDef(abstractColDef)) {\n        // creating 'dummy' group which is not associated with grid column group\n        var groupDef = abstractColDef;\n        var groupId = typeof groupDef.groupId !== 'undefined' ? groupDef.groupId : groupDef.headerName;\n        var group = new OriginalColumnGroup(groupDef, groupId, false, depth);\n        var children_1 = [];\n        groupDef.children.forEach(function (def) {\n          var child = createDummyColGroup(def, depth + 1); // check column exists in case invalid colDef is supplied for primary column\n\n          if (child) {\n            children_1.push(child);\n          }\n        });\n        group.setChildren(children_1);\n        return group;\n      } else {\n        var colDef = abstractColDef;\n        var key = colDef.colId ? colDef.colId : colDef.field;\n\n        var column = _this.columnModel.getPrimaryColumn(key);\n\n        if (!column) {\n          invalidColIds.push(colDef);\n        }\n\n        return column;\n      }\n    };\n\n    var mappedResults = [];\n    colDefs.forEach(function (colDef) {\n      var result = createDummyColGroup(colDef, 0);\n\n      if (result) {\n        // only return correctly mapped colDef results\n        mappedResults.push(result);\n      }\n    });\n\n    if (invalidColIds.length > 0) {\n      console.warn('AG Grid: unable to find grid columns for the supplied colDef(s):', invalidColIds);\n    }\n\n    return mappedResults;\n  };\n\n  ToolPanelColDefService.prototype.syncLayoutWithGrid = function (syncLayoutCallback) {\n    // extract ordered list of leaf path trees (column group hierarchy for each individual leaf column)\n    var leafPathTrees = this.getLeafPathTrees(); // merge leaf path tree taking split column groups into account\n\n    var mergedColumnTrees = this.mergeLeafPathTrees(leafPathTrees); // sync layout with merged column trees\n\n    syncLayoutCallback(mergedColumnTrees);\n  };\n\n  ToolPanelColDefService.prototype.getLeafPathTrees = function () {\n    // leaf tree paths are obtained by walking up the tree starting at a column until we reach the top level group.\n    var getLeafPathTree = function getLeafPathTree(node, childDef) {\n      var leafPathTree; // build up tree in reverse order\n\n      if (node instanceof OriginalColumnGroup) {\n        if (node.isPadding()) {\n          // skip over padding groups\n          leafPathTree = childDef;\n        } else {\n          var groupDef = _.assign({}, node.getColGroupDef()); // ensure group contains groupId\n\n\n          groupDef.groupId = node.getGroupId();\n          groupDef.children = [childDef];\n          leafPathTree = groupDef;\n        }\n      } else {\n        var colDef = _.assign({}, node.getColDef()); // ensure col contains colId\n\n\n        colDef.colId = node.getColId();\n        leafPathTree = colDef;\n      } // walk tree\n\n\n      var parent = node.getOriginalParent();\n\n      if (parent) {\n        // keep walking up the tree until we reach the root\n        return getLeafPathTree(parent, leafPathTree);\n      } else {\n        // we have reached the root - exit with resulting leaf path tree\n        return leafPathTree;\n      }\n    }; // obtain a sorted list of all grid columns\n\n\n    var allGridColumns = this.columnModel.getAllGridColumns(); // only primary columns and non row group columns should appear in the tool panel\n\n    var allPrimaryGridColumns = allGridColumns.filter(function (column) {\n      var colDef = column.getColDef();\n      return column.isPrimary() && !colDef.showRowGroup;\n    }); // construct a leaf path tree for each column\n\n    return allPrimaryGridColumns.map(function (col) {\n      return getLeafPathTree(col, col.getColDef());\n    });\n  };\n\n  ToolPanelColDefService.prototype.mergeLeafPathTrees = function (leafPathTrees) {\n    var _this = this;\n\n    var getLeafPathString = function getLeafPathString(leafPath) {\n      var group = leafPath;\n      return group.children ? group.groupId + getLeafPathString(group.children[0]) : '';\n    };\n\n    var matchingRootGroupIds = function matchingRootGroupIds(pathA, pathB) {\n      var bothPathsAreGroups = _this.isColGroupDef(pathA) && _this.isColGroupDef(pathB);\n\n      return bothPathsAreGroups && _this.getId(pathA) === _this.getId(pathB);\n    };\n\n    var mergeTrees = function mergeTrees(treeA, treeB) {\n      if (!_this.isColGroupDef(treeB)) {\n        return treeA;\n      }\n\n      var mergeResult = treeA;\n      var groupToMerge = treeB;\n\n      if (groupToMerge.children && groupToMerge.groupId) {\n        var added = _this.addChildrenToGroup(mergeResult, groupToMerge.groupId, groupToMerge.children[0]);\n\n        if (added) {\n          return mergeResult;\n        }\n      }\n\n      groupToMerge.children.forEach(function (child) {\n        return mergeTrees(mergeResult, child);\n      });\n      return mergeResult;\n    }; // we can't just merge the leaf path trees as groups can be split apart - instead only merge if leaf\n    // path groups with the same root group id are contiguous.\n\n\n    var mergeColDefs = [];\n\n    for (var i = 1; i <= leafPathTrees.length; i++) {\n      var first = leafPathTrees[i - 1];\n      var second = leafPathTrees[i];\n\n      if (matchingRootGroupIds(first, second)) {\n        leafPathTrees[i] = mergeTrees(first, second);\n      } else {\n        mergeColDefs.push(first);\n      }\n    }\n\n    return mergeColDefs;\n  };\n\n  ToolPanelColDefService.prototype.addChildrenToGroup = function (tree, groupId, colDef) {\n    var _this = this;\n\n    var subGroupIsSplit = function subGroupIsSplit(currentSubGroup, currentSubGroupToAdd) {\n      var existingChildIds = currentSubGroup.children.map(_this.getId);\n\n      var childGroupAlreadyExists = _.includes(existingChildIds, _this.getId(currentSubGroupToAdd));\n\n      var lastChild = _.last(currentSubGroup.children);\n\n      var lastChildIsDifferent = lastChild && _this.getId(lastChild) !== _this.getId(currentSubGroupToAdd);\n\n      return childGroupAlreadyExists && lastChildIsDifferent;\n    };\n\n    if (!this.isColGroupDef(tree)) {\n      return true;\n    }\n\n    var currentGroup = tree;\n    var groupToAdd = colDef;\n\n    if (subGroupIsSplit(currentGroup, groupToAdd)) {\n      currentGroup.children.push(groupToAdd);\n      return true;\n    }\n\n    if (currentGroup.groupId === groupId) {\n      // add children that don't already exist to group\n      var existingChildIds = currentGroup.children.map(this.getId);\n\n      var colDefAlreadyPresent = _.includes(existingChildIds, this.getId(groupToAdd));\n\n      if (!colDefAlreadyPresent) {\n        currentGroup.children.push(groupToAdd);\n        return true;\n      }\n    } // recurse until correct group is found to add children\n\n\n    currentGroup.children.forEach(function (subGroup) {\n      return _this.addChildrenToGroup(subGroup, groupId, colDef);\n    });\n    return false;\n  };\n\n  __decorate([Autowired('columnModel')], ToolPanelColDefService.prototype, \"columnModel\", void 0);\n\n  ToolPanelColDefService = __decorate([Bean('toolPanelColDefService')], ToolPanelColDefService);\n  return ToolPanelColDefService;\n}(BeanStub);\n\nexport { ToolPanelColDefService };","map":{"version":3,"sources":["C:/dev/streamlit-aggrid/st_aggrid/frontend/node_modules/@ag-grid-enterprise/side-bar/dist/es6/sideBar/common/toolPanelColDefService.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","_","Autowired","Bean","BeanStub","OriginalColumnGroup","ToolPanelColDefService","_super","_this","apply","isColGroupDef","colDef","children","getId","groupId","colId","createColumnTree","colDefs","invalidColIds","createDummyColGroup","abstractColDef","depth","groupDef","headerName","group","children_1","forEach","def","child","push","setChildren","field","column","columnModel","getPrimaryColumn","mappedResults","result","console","warn","syncLayoutWithGrid","syncLayoutCallback","leafPathTrees","getLeafPathTrees","mergedColumnTrees","mergeLeafPathTrees","getLeafPathTree","node","childDef","leafPathTree","isPadding","assign","getColGroupDef","getGroupId","getColDef","getColId","parent","getOriginalParent","allGridColumns","getAllGridColumns","allPrimaryGridColumns","filter","isPrimary","showRowGroup","map","col","getLeafPathString","leafPath","matchingRootGroupIds","pathA","pathB","bothPathsAreGroups","mergeTrees","treeA","treeB","mergeResult","groupToMerge","added","addChildrenToGroup","mergeColDefs","first","second","tree","subGroupIsSplit","currentSubGroup","currentSubGroupToAdd","existingChildIds","childGroupAlreadyExists","includes","lastChild","last","lastChildIsDifferent","currentGroup","groupToAdd","colDefAlreadyPresent","subGroup"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { _, Autowired, Bean, BeanStub, OriginalColumnGroup } from \"@ag-grid-community/core\";\nvar ToolPanelColDefService = /** @class */ (function (_super) {\n    __extends(ToolPanelColDefService, _super);\n    function ToolPanelColDefService() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.isColGroupDef = function (colDef) { return colDef && typeof colDef.children !== 'undefined'; };\n        _this.getId = function (colDef) {\n            return _this.isColGroupDef(colDef) ? colDef.groupId : colDef.colId;\n        };\n        return _this;\n    }\n    ToolPanelColDefService.prototype.createColumnTree = function (colDefs) {\n        var _this = this;\n        var invalidColIds = [];\n        var createDummyColGroup = function (abstractColDef, depth) {\n            if (_this.isColGroupDef(abstractColDef)) {\n                // creating 'dummy' group which is not associated with grid column group\n                var groupDef = abstractColDef;\n                var groupId = (typeof groupDef.groupId !== 'undefined') ? groupDef.groupId : groupDef.headerName;\n                var group = new OriginalColumnGroup(groupDef, groupId, false, depth);\n                var children_1 = [];\n                groupDef.children.forEach(function (def) {\n                    var child = createDummyColGroup(def, depth + 1);\n                    // check column exists in case invalid colDef is supplied for primary column\n                    if (child) {\n                        children_1.push(child);\n                    }\n                });\n                group.setChildren(children_1);\n                return group;\n            }\n            else {\n                var colDef = abstractColDef;\n                var key = colDef.colId ? colDef.colId : colDef.field;\n                var column = _this.columnModel.getPrimaryColumn(key);\n                if (!column) {\n                    invalidColIds.push(colDef);\n                }\n                return column;\n            }\n        };\n        var mappedResults = [];\n        colDefs.forEach(function (colDef) {\n            var result = createDummyColGroup(colDef, 0);\n            if (result) {\n                // only return correctly mapped colDef results\n                mappedResults.push(result);\n            }\n        });\n        if (invalidColIds.length > 0) {\n            console.warn('AG Grid: unable to find grid columns for the supplied colDef(s):', invalidColIds);\n        }\n        return mappedResults;\n    };\n    ToolPanelColDefService.prototype.syncLayoutWithGrid = function (syncLayoutCallback) {\n        // extract ordered list of leaf path trees (column group hierarchy for each individual leaf column)\n        var leafPathTrees = this.getLeafPathTrees();\n        // merge leaf path tree taking split column groups into account\n        var mergedColumnTrees = this.mergeLeafPathTrees(leafPathTrees);\n        // sync layout with merged column trees\n        syncLayoutCallback(mergedColumnTrees);\n    };\n    ToolPanelColDefService.prototype.getLeafPathTrees = function () {\n        // leaf tree paths are obtained by walking up the tree starting at a column until we reach the top level group.\n        var getLeafPathTree = function (node, childDef) {\n            var leafPathTree;\n            // build up tree in reverse order\n            if (node instanceof OriginalColumnGroup) {\n                if (node.isPadding()) {\n                    // skip over padding groups\n                    leafPathTree = childDef;\n                }\n                else {\n                    var groupDef = _.assign({}, node.getColGroupDef());\n                    // ensure group contains groupId\n                    groupDef.groupId = node.getGroupId();\n                    groupDef.children = [childDef];\n                    leafPathTree = groupDef;\n                }\n            }\n            else {\n                var colDef = _.assign({}, node.getColDef());\n                // ensure col contains colId\n                colDef.colId = node.getColId();\n                leafPathTree = colDef;\n            }\n            // walk tree\n            var parent = node.getOriginalParent();\n            if (parent) {\n                // keep walking up the tree until we reach the root\n                return getLeafPathTree(parent, leafPathTree);\n            }\n            else {\n                // we have reached the root - exit with resulting leaf path tree\n                return leafPathTree;\n            }\n        };\n        // obtain a sorted list of all grid columns\n        var allGridColumns = this.columnModel.getAllGridColumns();\n        // only primary columns and non row group columns should appear in the tool panel\n        var allPrimaryGridColumns = allGridColumns.filter(function (column) {\n            var colDef = column.getColDef();\n            return column.isPrimary() && !colDef.showRowGroup;\n        });\n        // construct a leaf path tree for each column\n        return allPrimaryGridColumns.map(function (col) { return getLeafPathTree(col, col.getColDef()); });\n    };\n    ToolPanelColDefService.prototype.mergeLeafPathTrees = function (leafPathTrees) {\n        var _this = this;\n        var getLeafPathString = function (leafPath) {\n            var group = leafPath;\n            return group.children ? group.groupId + getLeafPathString(group.children[0]) : '';\n        };\n        var matchingRootGroupIds = function (pathA, pathB) {\n            var bothPathsAreGroups = _this.isColGroupDef(pathA) && _this.isColGroupDef(pathB);\n            return bothPathsAreGroups && _this.getId(pathA) === _this.getId(pathB);\n        };\n        var mergeTrees = function (treeA, treeB) {\n            if (!_this.isColGroupDef(treeB)) {\n                return treeA;\n            }\n            var mergeResult = treeA;\n            var groupToMerge = treeB;\n            if (groupToMerge.children && groupToMerge.groupId) {\n                var added = _this.addChildrenToGroup(mergeResult, groupToMerge.groupId, groupToMerge.children[0]);\n                if (added) {\n                    return mergeResult;\n                }\n            }\n            groupToMerge.children.forEach(function (child) { return mergeTrees(mergeResult, child); });\n            return mergeResult;\n        };\n        // we can't just merge the leaf path trees as groups can be split apart - instead only merge if leaf\n        // path groups with the same root group id are contiguous.\n        var mergeColDefs = [];\n        for (var i = 1; i <= leafPathTrees.length; i++) {\n            var first = leafPathTrees[i - 1];\n            var second = leafPathTrees[i];\n            if (matchingRootGroupIds(first, second)) {\n                leafPathTrees[i] = mergeTrees(first, second);\n            }\n            else {\n                mergeColDefs.push(first);\n            }\n        }\n        return mergeColDefs;\n    };\n    ToolPanelColDefService.prototype.addChildrenToGroup = function (tree, groupId, colDef) {\n        var _this = this;\n        var subGroupIsSplit = function (currentSubGroup, currentSubGroupToAdd) {\n            var existingChildIds = currentSubGroup.children.map(_this.getId);\n            var childGroupAlreadyExists = _.includes(existingChildIds, _this.getId(currentSubGroupToAdd));\n            var lastChild = _.last(currentSubGroup.children);\n            var lastChildIsDifferent = lastChild && _this.getId(lastChild) !== _this.getId(currentSubGroupToAdd);\n            return childGroupAlreadyExists && lastChildIsDifferent;\n        };\n        if (!this.isColGroupDef(tree)) {\n            return true;\n        }\n        var currentGroup = tree;\n        var groupToAdd = colDef;\n        if (subGroupIsSplit(currentGroup, groupToAdd)) {\n            currentGroup.children.push(groupToAdd);\n            return true;\n        }\n        if (currentGroup.groupId === groupId) {\n            // add children that don't already exist to group\n            var existingChildIds = currentGroup.children.map(this.getId);\n            var colDefAlreadyPresent = _.includes(existingChildIds, this.getId(groupToAdd));\n            if (!colDefAlreadyPresent) {\n                currentGroup.children.push(groupToAdd);\n                return true;\n            }\n        }\n        // recurse until correct group is found to add children\n        currentGroup.children.forEach(function (subGroup) { return _this.addChildrenToGroup(subGroup, groupId, colDef); });\n        return false;\n    };\n    __decorate([\n        Autowired('columnModel')\n    ], ToolPanelColDefService.prototype, \"columnModel\", void 0);\n    ToolPanelColDefService = __decorate([\n        Bean('toolPanelColDefService')\n    ], ToolPanelColDefService);\n    return ToolPanelColDefService;\n}(BeanStub));\nexport { ToolPanelColDefService };\n"]},"metadata":{},"sourceType":"module"}