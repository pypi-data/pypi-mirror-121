# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/Client.ipynb (unless otherwise specified).

__all__ = ["Client", "DataSource", "ProgressStatus", "Model", "Prediction"]

# Internal Cell

""" Client module

    This module encapsulates all classes conncted to the API service.

"""

# Cell

from typing import *

# Internal Cell

import os
from time import sleep
import requests
from datetime import datetime, timedelta

import pandas as pd
from tqdm import tqdm

from fastcore.foundation import patch

# Internal Cell


def _ensure_is_instance(o: Any, cls: Type):
    """A function to check if the object argument is an instance of the class argument.

    Args:
        o: A python object for which the instance needs to be checked.
        cls: The expected instance of the object argument.

    Raises:
        A TypeError if the object is not an instance of the class type.
    """
    if not isinstance(o, cls):
        raise TypeError(
            f"The parameter must be a {cls} type, but got `{type(o).__name__}`"
        )


# Internal Cell


def _check_status(response: requests.Response) -> Dict[str, Any]:
    """A function to validate the status of the response object.

    Args:
        response: The response object that encapsulates the server's response.

    Returns:
        A dictionary of the response body.

    Raises:
        ValueError: If the response from the server is not in the range 200 and 399.
    """
    if response:
        return response.json()
    else:
        raise ValueError(response.json()["detail"])


# Internal Cell


def _post_data(
    url: str,
    data: dict,
    token: Optional[str],
) -> Dict[str, Any]:
    """A function to send a POST request.

    Args:
        url: The URL of the server to which the request needs to be sent.
        data: A Dictionary object to send in the body of the POST request.
        token: The unique auth token for the client, obtained via calling the `Client.authenticate` method.
            Set it to `None` in `Client.authenticate()` to obtain the token.

    Returns:
        A dictionary that encapsulates the response body.

    Raises:
        ConnectionError: If the server is not reachable.
        ValueError: If the response from the server is not in the range 200 and 399.
    """
    if token is not None:
        headers = {"Authorization": f"Bearer {token}"}
        response = requests.post(url, json=data, headers=headers)
    else:
        response = requests.post(url, data=data)
    return _check_status(response)


# Internal Cell


def _get_data(url: str, token: str) -> Dict[str, Any]:
    """A function to send a GET request.

    Args:
        url: The URL of the server to which the request needs to be sent.
        token: The unique auth token for the client, obtained via calling the `Client.authenticate` method.

    Returns:
        A dictionary that encapsulates the response body.

    Raises:
        ConnectionError: If the server is not reachable.
        ValueError: If the response from the server is not in the range 200 and 399.
    """
    headers = {"Authorization": f"Bearer {token}"}
    response = requests.get(url, headers=headers)
    return _check_status(response)


# Cell


class Client:
    """A class for authenticating and accessing the airt service.

    Before you can use the service, you must acquire a username and password for your developer account. Please contact us by email info@airt.ai to get one.

    The username, password, and server address can be passed explicitly while calling the `authenticate` method in the `Client` class or stored
    permanently in environment variables `AIRT_SERVICE_USERNAME`, `AIRT_SERVICE_PASSWORD`, and `AIRT_SERVER_URL` respectively.

    Upon successful authentication, the airt services will be available to access.
    """

    server = ""
    auth_token = ""

    @classmethod
    def authenticate(
        cls, *, username: str = None, password: str = None, server: str = None
    ):
        """A class method to authenticate and validate the developer token for accessing the airt services.

        The authenticate method calls the AIRT services for validating the given username and password. Upon successful
        authentication, an auth token will be returned and will be implicitly used in all the subsequent interactions with the server.

        Args:
            username: Username for your developer account. If not set (default value `None`), it will try to
                use the value from environment variable `AIRT_SERVICE_USERNAME`.
            password: Password for your developer account. If not set (default value `None`), it will try to
                use the value from environment variable `AIRT_SERVICE_PASSWORD`.
            server: Server address used to connect to. If not set (default value `None`), it will try to
                use the value from environment variable `AIRT_SERVER_URL`. If the variable is not set as well,
                then the default public server will be used. You should leave this to default value unless you
                are running your own server (please contact us for that possibility by email info@airt.ai).

        Raises:
            ValueException: If the `username`/`password` pair does not match the one for sevice hosted at `server`.
            ConnectionError: If the server address is invalid or not reachable.
        """
        env_airt_service_username = "AIRT_SERVICE_USERNAME"
        env_airt_service_password = "AIRT_SERVICE_PASSWORD"
        env_airt_service_address = "AIRT_SERVER_URL"
        airt_prod_server_URI = "https://api.airt.ai"

        cls.server = (
            server
            if server is not None
            else os.environ.get(env_airt_service_address, airt_prod_server_URI)
        )

        res = _post_data(
            url=f"{cls.server}/token",
            data=dict(
                username=(
                    username
                    if username is not None
                    else os.environ[env_airt_service_username]
                ),
                password=(
                    password
                    if password is not None
                    else os.environ[env_airt_service_password]
                ),
            ),
            token=None,
        )
        cls.auth_token = res["access_token"]

    @classmethod
    def _get_server_url_and_token(cls) -> Tuple[str, str]:
        """A class method for fetching the server URL and the auth token.

        Returns:
            A tuple containing server URL and auth token.
        """
        return cls.server, cls.auth_token

    @classmethod
    def post_data(cls, relative_url: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """A class method to initiate a POST request.

        This method will implicitly add the server base URL and the token for every request.

        Args:
            relative_url: The relative URL of the server's API endpoint.
            data: A Dictionary object to send in the body of the POST request.

        Returns:
            A dictionary that has the response body.

        Raises:
            ConnectionError: If the server is not reachable.
            ValueError: If the response from the server is not in the range 200 and 399.
        """
        return _post_data(
            url=f"{cls.server}{relative_url}",
            data=data,
            token=cls.auth_token,
        )

    @classmethod
    def get_data(cls, relative_url: str) -> Dict[str, Any]:
        """A class method to initiate a GET request.

        This method will implicitly add the server base URL and the token for every request.

        Args:
            relative_url: The relative URL of the API endpoint.

        Returns:
            A dictionary that encapsulates the response body.

        Raises:
            ConnectionError: If the server is not reachable.
            ValueError: If the response from the server is not in the range 200 and 399.
        """

        return _get_data(url=f"{cls.server}{relative_url}", token=cls.auth_token)


# Cell


class DataSource:
    """A class for encapsulating the data from sources like AWS S3 bucket or a database.

    The DataSource class is automatically instantiated by calling either the s3 or the db static methods of a DataSource class.
    Currently, it is the only way to instantiate this class.

    Currently, we support reading and pushing the data to:

    - a MySql database, and

    - an AWS S3 bucket in the Parquet file format.

    We plan to add other databases and storage mediums in the future.

    For establishing the connection to the MySql database, parameters like host, port,
    database name, table name needs are required.

    And for establishing a connection to the S3 bucket, URI to the target parquet file
    is required.

    In case if access to the database requires authentication, the required username and
    password for the database are automatically read from either the environment variables
    `AIRT_CLIENT_DB_USERNAME` and `AIRT_CLIENT_DB_PASSWORD` or from the username and password
    parameters that are passed to the `DataSource.db` function.

    All the function calls to the library are asynchronous and they return immediately.
    To manage completion, all methods inside the returned object will return a status object
    and a method to display an interactive progress bar that can be called to check the progress.

    Below are code examples for accessing the above methods:

    An example to check for the status flag of s3 connection:

    ```python
    data_source_s3 = DataSource.s3(
        uri="s3://bucket/events.parquet"
    )
    status = data_source_s3.pull()
    status.is_ready()
    ```

    An example to display an interactive progress bar of s3 connection:

    ```python
    data_source_s3 = DataSource.s3(
        uri="s3://bucket/events.parquet"
    )
    data_source_s3.pull().progress_bar()
    ```

    """

    def __init__(
        self,
        data_id: int,
    ):
        """Constructs a new DataSource instance.

        Warning:
            Do not construct this object directly by calling the constructor, please use `DataSource.db()` or `DataSource.s3()` function instead.

        Args:
            data_id: ID of the data in the airt service.
        """
        self.id = data_id

    @staticmethod
    def db(
        *,
        host: str,
        database: str,
        table: str,
        port: Optional[int] = 3306,
        engine: Optional[str] = None,
        username: Optional[str] = None,
        password: Optional[str] = None,
    ) -> "DataSource":
        """A static function to create DB backed data source

        A static method that creates and returns an object that encapsulates the data
        from a database. In case if access to the database requires authentication,
        the username and password will be read either from the arguments or in the airt
        environment variables.

        The objects created by calling this method won't establish the connection yet.

        Args:
            host: The host name (subdomain) of the database server as a string.
            database: The name of the database for establishing the connection as string.
            table: The name of the table present in the database for querying as a string.
            port: The port number as a string. If the value is not passed then the default
                port number will be used (e.g. for MySQL we will use 3306)
            engine: The name of the database engine as a string. If the value is not passed
                then the default database engine for MySQL will be used.
            username: The username to connect to the database as a string. If not set (default value `root`),
                it will try to use the value from environment variable `AIRT_CLIENT_DB_USERNAME`.
            password: The username to connect to the database as a string. If not set (default value ``),
                it will try to use the value from environment variable `AIRT_CLIENT_DB_PASSWORD`.

        Returns:
            An instance of the `DataSource` class. For more information on the methods that
            are available in the returned object, please check the documentation of the
            `DataSource` class.

        Raises:
            ValueError: If the requred parameters are empty or None.
            ValueError: If the requred parameters to the API are invalid.
            ConnectionError: If the server address is invalid or not reachable.

        An example function call to the DataSource.db:

        ```python
        data_source = DataSource.db(
            host="db.staging.airt.ai",
            database="test",
            table="events"
        )
        ```
        """
        _ensure_is_instance(host, str)
        _ensure_is_instance(database, str)
        _ensure_is_instance(table, str)

        username = (
            username
            if username is not None
            else os.environ.get("AIRT_CLIENT_DB_USERNAME", "root")
        )

        password = (
            password
            if password is not None
            else os.environ.get("AIRT_CLIENT_DB_PASSWORD", "")
        )

        req_data = dict(
            host=host,
            port=port,
            username=username,
            password=password,
            database=database,
            table=table,
        )

        res = Client.post_data(relative_url=f"/data/db", data=req_data)

        return DataSource(data_id=res["id"])

    @staticmethod
    def s3(
        *,
        uri: str = None,
        access_key: str = None,
        secret_key: str = None,
    ) -> "DataSource":
        """A static method that creates and returns an object that encapsulates the data from a AWS S3 bucket.

        Args:
            uri: The AWS S3 bucket location of the Parquet files as a string.
            access_key: The access key for the S3 bucket. If `None` (default value), then the value
                of environment variable `AWS_ACCESS_KEY_ID` is used.
            secret_key: The secret key for the S3 bucket. If `None` (default value), then the value
                of environment variable `AWS_SECRET_ACCESS_KEY` is used.

        Returns:
            An instance of the `DataSource` class. For more information on the methods that are available in
            the returned object, please check the documentation of the `DataSource` class.

        Raises:
            ValueError: If the parameters `client` and `URI` are empty or None.
            ValueError: If the input parameters to the API are invalid.
            ConnectionError: If the server address is invalid or not reachable.

        An example function call to the DataSource.s3:

        ```python
            data_source_s3 = DataSource.s3(
                uri="s3://bucket/events.parquet"
            )
        ```
        """
        _ensure_is_instance(uri, str)

        access_key = (
            access_key if access_key is not None else os.environ["AWS_ACCESS_KEY_ID"]
        )
        secret_key = (
            secret_key
            if secret_key is not None
            else os.environ["AWS_SECRET_ACCESS_KEY"]
        )

        res = Client.post_data(
            relative_url="/data/s3",
            data=dict(uri=uri, access_key=access_key, secret_key=secret_key),
        )

        return DataSource(data_id=res["id"])

    @property
    def dtypes(self) -> Dict[str, str]:
        """A function that parses the data source in the airt service and returns the column names and their dtypes.

        Returns:
            A dictionary that contains the column names and its type as string only key value pairs.

        Raises:
            ValueError: If the input parameters to the API are invalid.
            ConnectionError: If the server address is invalid or not reachable.

        Below is an example to check the dtypes of the connected datasource:

        ```python
        data_source_s3 = DataSource.s3(
            uri="s3://bucket/events.parquet"
        )
        data_source_s3.pull().progress_bar()
        data_source_s3.dtypes
        ```
        """
        return Client.get_data(relative_url=f"/data/{int(self.id)}/dtypes")


# Cell


class ProgressStatus:
    """A base class for querying status of a remote operation"""

    def __init__(self, relative_url: str):
        """Constructs a new ProgressStatus instance.

        Warning:
            Do not construct this object directly by calling the constructor, please use `DataSource.pull()` or `DataSource.train()` or `Modal.predict()` functions instead.

        Args:
            relative_url: The relative URL to the rest API endpoint.
        """
        self.relative_url = relative_url

    def is_ready(self) -> bool:
        """A function to check if the method's progress is completed.

        Returns:
            True if the progress if completed, else False.
        """
        response = Client.get_data(relative_url=self.relative_url)
        return True if response["completed_steps"] == response["total_steps"] else False

    def progress_bar(self, sleep_for: int = 5, timeout: int = 0):
        """Blocks execution while waiting for remote action to be completed and displays a progress bar indicating the completion status.

        Args:
            sleep_for: The time interval in seconds between successive API calls to ping the server for fetching the completed steps.
            timeout: The maximum time allowed in seconds for the asynchronous call to complete the process. If the timeout
                exceeds and the process is yet to complete, then the progress_bar will be terminated.
        """
        total_steps = Client.get_data(relative_url=self.relative_url)["total_steps"]
        with tqdm(total=total_steps) as pbar:
            prev_completed_steps = 0
            i = 0
            while True:
                if 0 < timeout <= i:
                    break
                response = Client.get_data(relative_url=self.relative_url)
                completed_steps = response["completed_steps"]
                if completed_steps != prev_completed_steps:
                    pbar.update(completed_steps - prev_completed_steps)
                    prev_completed_steps = completed_steps
                if completed_steps == total_steps:
                    break
                sleep(sleep_for)
                i = i + sleep_for


# Cell


@patch
def pull(self: DataSource) -> ProgressStatus:
    """A function to establish the connection with the data source.

    The pull method establishes the connection with the specified `DataSource` and pulls the
    data into the server for further processing. The call to this method is asynchronous and the progress of the connection can be checked
    using the progress bar or the status flag. Please refer to `DataSource` class documentation for more information.

    Returns:
        An instance of `ProgressStatus` class. `ProgressStatus` is a base class for querying status of a remote operation. For more information
        please refer to `ProgressStatus` class documentation.

    Raises:
        ValueError: If the input parameters to the API are invalid.
        ConnectionError: If the server address is invalid or not reachable.

    Below example shows establishing a connection with the s3 bucket:

    ```python

    Client.authenticate()
    data_source_s3 = DataSource.s3(
        uri="s3://test-airt-service/ecommerce_behavior"
    )

    data_source_s3.pull().progress_bar()
    ```
    """
    Client.get_data(relative_url=f"/data/{int(self.id)}/pull")
    return ProgressStatus(relative_url=f"/data/{int(self.id)}")


# Cell


@patch
def head(self: DataSource) -> pd.DataFrame:
    """A function to display the first few records of the data source.

    After successfully pulling the data into the server, the head function can be used
    to display the first few records of the downloaded data.

    Returns:
        A pandas dataframe that displays the first few records of the connected data source.

    Raises:
        ValueError: If the input parameters to the API are invalid.
        ConnectionError: If the server address is invalid or not reachable.

    An example to show the first few records of the data source

    ```python

    Client.authenticate()
    data_source_s3 = DataSource.s3(
        uri="s3://test-airt-service/ecommerce_behavior"
    )
    data_source_s3.pull().progress_bar()

    data_source_s3.head()
    ```
    """
    res = Client.get_data(relative_url=f"/data/{int(self.id)}/head")
    return pd.DataFrame(res)


# Cell


class Model(ProgressStatus):
    """A class for querying the status of the model training, evaluation, and prediction on the remote server.

    A `Model` class is automatically instantiated when the train() method of the `DataSource` class.
    Currently, it is the only way to instantiate the Model class.

    The model is trained on the connected data and tries to predict a specific event in the future.
    For the model training and prediction, we assume the input data includes the following:

    - a column identifying a client client_column (person, car, business, etc.),

    - a column specifying a type of event we will try to predict target_column (buy, checkout, etc.),

    - a timestamp column specifying the time of an occurred event.

    Along with the above mandatory fields, each row in the data might have additional columns of int,
    category, float, or datetime type and they will be used to make predictions more accurate.

    Finally, we need to know how much ahead we wish to make predictions for. That lead time varies
    widely from application to application and can be in minutes for a webshop or even several weeks for a banking product such as a loan.

    As always, the model training and prediction will happen asynchronously and can take a few hours
    based on the size of your dataset.

    The respective status can be viewed by calling the progress_bar() or the status flag available on
    the returned object. For more information, please check the documentation of `DataSource`

    """

    def __init__(self, model_id: int):
        """Constructs a new `Model` instance

        Warning:
            Do not construct this object directly by calling the constructor, please use
            `DataSource.train()` function instead.

        Args:
            model_id: ID of the model in the airt service
        """
        self.model_id = model_id
        ProgressStatus.__init__(self, relative_url=f"/model/{self.model_id}")


# Cell


@patch
def train(
    self: DataSource,
    *,
    client_column: str,
    timestamp_column: Optional[str] = None,
    target_column: str,
    target: str,
    predict_after: timedelta,
) -> Model:
    """A method to train the ML model on the connected `DataSource`.

    This method trains the model for predicting which clients are most likely to have a specified
    event in the future. The call to this method is asynchronous and the progress of the connection
    can be checked using the progress bar method or the status flag attribute available in the `DataSource` class.
    For more information on the model, please check the documentation of `Model` class.

    Args:
        client_column: The name of the column that uniquely identifies the users/clients as string.
        timestamp_column: Optional; Name of the timestamp_column specifying the time of an
            occurred event as a string. If the value is not passed then the timestamp_column will
            not be used for model training.
        target_column: Name of the target column that captures the type of event as string. This will
            be used for training the model as well as for making predictions for our target event.
        target: Name of the target event for which the model needs to be trained to make predictions.
            You can pass regular expressions as well to this parameter for making predictions for more than one event.
            For example, the passing `*checkout` will train a model to predict which users will do any kind of a
            checkout event.
        predict_after: Time delta in hours of the expected target event mentioned as timedelta.

    Returns:
        An instance of the `Model` class.

    Raises:
        ValueError: If any of the required parameters are empty or None.
        ValueError: If the input parameters to the API are invalid.
        ConnectionError: If the server address is invalid or not reachable.

    Below is an example for training a model to predict which users will perform a purchase event (`*purchase`) 3 hours before they acctually do it:

    ```python
    from datetime import timedelta

    model = data_source_s3.train(
        client_column="user_id",
        target_column="event_type",
        target="*purchase",
        predict_after=timedelta(hours=3)
    )

    model.progress_bar()
    ```
    """
    _ensure_is_instance(predict_after, timedelta)
    _ensure_is_instance(client_column, str)
    _ensure_is_instance(target_column, str)
    _ensure_is_instance(target, str)

    res = Client.post_data(
        relative_url=f"/model/train",
        data=dict(
            data_id=int(self.id),
            client_column=client_column,
            target_column=str(target_column),
            target=str(target),
            predict_after=int(predict_after.total_seconds()),
        ),
    )
    return Model(model_id=res["id"])


# Cell


class Prediction(ProgressStatus):
    """A class to that uses the trained model for making predictions on the connected data.

    The `Predict` class is automatically instantiated by calling the `train` method of a `Client` instance.
    Currently, it is the only way to instantiate this class. The returned object will have utility methods like converting the prediction
    results into a pandas dataframe and pushing the prediction results into one of the supported data sources etc.,

    For more information on the supported data sources, please refer to the documentation on `DataSource` class
    """

    def __init__(self, prediction_id: int):
        """Constructs a new `Prediction` instance

        Warning:
            Do not construct this object directly by calling the constructor, please use
            `Model.predict()` function instead.

        Args:
            prediction_id: ID of the prediction in the airt service
        """
        self.prediction_id = prediction_id
        ProgressStatus.__init__(self, relative_url=f"/prediction/{self.prediction_id}")

    def push(self, data_source: DataSource):
        """A function to push the prediction results into the target data source.

        For more information on the supported data sources, please refer to the documentation on `DataSource` class

        Args:
            data_source: An instance of the `DataSource` class that encapsulates the data.

        Raises:
            ValueError: If the input parameters to the API are invalid.
            ConnectionError: If the server address is invalid or not reachable.


        The below example illustrates pushing the prediction results to a database:

        ```python
        from datetime import timedelta

        Client.authenticate()
        data_source_s3 = DataSource.s3(
            uri="s3://test-airt-service/ecommerce_behavior"
        )
        data_source_s3.pull().progress_bar()
        model = data_source_s3.train(
            client_column="user_id",
            target_column="event_type",
            target="*purchase",
            predict_after=timedelta(hours=3),
        )
        data_source_pred = DataSource.s3(
            uri="s3://target-bucket"
        )
        predictions = model.predict()
        predictions.push(data_source_pred)
        ```
        """
        _ensure_is_instance(data_source, DataSource)
        Client.post_data(
            relative_url=f"/prediction/{self.prediction_id}/push",
            data=dict(data_id=data_source.id),
        )


# Cell


@patch
def evaluate(self: Model) -> pd.DataFrame:
    """A function to evaluate the performance of the trained model.

    This function returns the performance metrics like accuracy, precision, and recall. Currently,
    the function returns only the above-mentioned metrics and we plan to add more performance metrics in the future.

    Returns:
        A pandas Series that has the performance metrics of the trained model.

    Raises:
        ValueError: If the input parameters to the API are invalid.
        ConnectionError: If the server address is invalid or not reachable.
    """
    model_evaluate = Client.get_data(relative_url=f"/model/{self.model_id}/evaluate")
    return pd.DataFrame(dict(model_evaluate), index=[0]).T.rename(columns={0: "eval"})


# Cell


@patch
def predict(self: Model) -> "Prediction":
    """A function that uses the trained model and makes predictions.

    As always, this function is asynchronous and can take a few hours based on the size of your dataset. The status of
    the model prediction can be viewed interactively by calling the `progress_bar` method available on the returned object.
    For more information, please check the documentation of `DataSource`

    Returns:
        An instance of the `Prediction` class. For more information on the methods that are available in
        the returned object, please check the documentation of the `Prediction` class

    Raises:
        ValueError: If the input parameters to the API are invalid.
        ConnectionError: If the server address is invalid or not reachable.
    """
    datasource_id = Client.get_data(relative_url=f"/model/{self.model_id}")[
        "datasource_id"
    ]

    res = Client.post_data(
        relative_url=f"/model/{self.model_id}/predict", data=dict(data_id=datasource_id)
    )

    return Prediction(prediction_id=res["id"])


# Cell


@patch
def to_pandas(self: Prediction) -> pd.DataFrame:
    """A function to convert the predicted results into a Pandas DataFrame object.

    Returns:
        A Pandas DataFrame that contains the prediction results from the model.

    Raises:
        ValueError: If the input parameters to the API are invalid.
        ConnectionError: If the server address is invalid or not reachable.

    The below example illustrates the usage of to_pandas function:

    ```python
    from datetime import timedelta

    Client.authenticate()
    data_source_s3 = DataSource.s3(
        uri="s3://test-airt-service/ecommerce_behavior"
    )
    data_source_s3.pull().progress_bar()
    model = data_source_s3.train(
        client_column="user_id",
        target_column="event_type",
        target="*purchase",
        predict_after=timedelta(hours=3),
    )

    predictions = model.predict()
    predictions.to_pandas()
    ```
    """
    response = Client.get_data(relative_url=f"/prediction/{self.prediction_id}/pandas")
    keys = list(response.keys())
    keys.remove("Score")
    index_name = keys[0]
    return (
        pd.DataFrame(response)
        .set_index(index_name)
        .sort_values("Score", ascending=False)
    )


# Cell


@patch
def push(self: DataSource, predictions: Prediction):
    """A function to push the prediction results into the target data source.

    For more information on the supported data sources, please refer to the documentation on `DataSource` class.

    Args:
        predictions: An instance of the `Prediction` class.

    Raises:
        ValueError: If the input parameters to the API are invalid.
        ConnectionError: If the server address is invalid or not reachable.

    The below example illustrates pushing the prediction results to a database:

    ```python
    from datetime import timedelta

    Client.authenticate()
    data_source_s3 = DataSource.s3(
        uri="s3://test-airt-service/ecommerce_behavior"
    )
    data_source_s3.pull().progress_bar()
    model = data_source_s3.train(
        client_column="user_id",
        target_column="event_type",
        target="*purchase",
        predict_after=timedelta(hours=3),
    )
    data_source_pred = DataSource.s3(
        uri="s3://target-bucket"
    )
    predictions = model.predict()
    data_source_pred.push(predictions)
    ```
    """
    predictions.push(data_source=self)
