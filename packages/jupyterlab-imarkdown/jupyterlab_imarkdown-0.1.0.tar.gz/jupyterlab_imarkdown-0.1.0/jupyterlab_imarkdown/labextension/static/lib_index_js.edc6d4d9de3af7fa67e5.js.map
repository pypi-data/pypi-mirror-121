{"version":3,"file":"lib_index_js.edc6d4d9de3af7fa67e5.js","mappings":";;;;;;;;;;;;;;;;AAAO;AACA;AACA;AACP;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACPiD;AACT;AACY;AACqB;AACzE;AACO;AACP;AACO;AACP;AACO;AACP;AACO;AACA,4BAA4B,2DAAY;AAC/C;AACA;AACA;AACA;AACA;AACA,mCAAmC,8DAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc,IAAI,eAAe;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,KAAK;AAC3D;AACA;AACA;AACA,+CAA+C,wDAAe,oDAAoD,uDAAc;AAChI;AACA;AACA;AACA;AACA,wEAAwE,KAAK;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,8DAAe;AACtD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,iDAAU,CAAC;AAChF;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB,GAAG,MAAM;AACvD;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACjLkC;AACsD;AAC/B;AACC;AACX;AAC/C,sCAAsC,8EAA4B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gDAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+EAA6B;AAC3C,eAAe,mEAAe;AAC9B;AACA;AACA;AACA;AACA,6CAA6C,eAAe;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAiB;AACxC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAgB;AAC/B;AACA;AACA;AACA,yBAAyB,0EAAwB;AACjD;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAmB;AACnC;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2CAAM;AAC1C,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;ACxFiD;AACxE;AACA;AACA;AACA;AACO;AACP;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oDAAO,WAAW,uDAAc,GAAG,wDAAe;AAC/E;AACA;AACA;AACA;AACA;AACA,kCAAkC,KAAK;AACvC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1C8C;AACuB;AACrE;AACA;AACA;AACA;AACO,eAAe,mFAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,0BAA0B;AAC1B,2BAA2B;AAC3B;AACA,gBAAgB,uDAAgB;AAChC;AACA,CAAC;;;;;;;;;;;;;;;;ACpBM;AACA;AACP;AACA,qIAAqI;AACrI,uIAAuI;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://jupyterlab-imarkdown/./lib/attachment.js","webpack://jupyterlab-imarkdown/./lib/cell.js","webpack://jupyterlab-imarkdown/./lib/index.js","webpack://jupyterlab-imarkdown/./lib/kernel.js","webpack://jupyterlab-imarkdown/./lib/plugin.js","webpack://jupyterlab-imarkdown/./lib/tokenize.js"],"sourcesContent":["export const OUTPUT_MIMETYPE = 'application/vnd.jupyterlab-imarkdown.output';\nexport const ERROR_MIMETYPE = 'application/vnd.jupyterlab-imarkdown.error';\nexport function isOutput(output) {\n    return output.status === 'ok';\n}\nexport function isError(output) {\n    return output.status === 'error';\n}\n","import { MarkdownCell } from '@jupyterlab/cells';\nimport { EXPR_CLASS } from './tokenize';\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { ERROR_MIMETYPE, isOutput, OUTPUT_MIMETYPE } from './attachment';\n// Name prefix for cell attachments\nexport const ATTACHMENT_PREFIX = 'jupyterlab-imarkdown';\n// Base CSS class for jupyterlab-imarkdown outputs\nexport const RENDERED_CLASS = 'im-rendered';\n// CSS class for execution-result outputs\nexport const RESULT_CLASS = 'im-result';\n// CSS class for missing outputs\nexport const ERROR_CLASS = 'im-error';\nexport class XMarkdownCell extends MarkdownCell {\n    constructor(options) {\n        super(options);\n        this.__expressions = {};\n        this.__placeholders = {};\n        this.__lastContent = '';\n        this.__doneRendering = new PromiseDelegate();\n        this.__rendermime = options.rendermime;\n    }\n    /**\n     * Get a mapping of names to kernel expressions.\n     */\n    get expressions() {\n        return this.__expressions;\n    }\n    /**\n     * Whether the Markdown renderer has finished rendering.\n     */\n    get doneRendering() {\n        return this.__doneRendering.promise;\n    }\n    /**\n     * Create an IRenderMime.IMimeModel for a given IExpressionResult\n     */\n    _createExpressionResultModel(payload) {\n        let options;\n        if (isOutput(payload)) {\n            // Output results are simple to re-intepret\n            options = {\n                trusted: this.model.trusted,\n                data: payload.data,\n                metadata: payload.metadata\n            };\n        }\n        else {\n            // Errors need to be formatted as stderr objects\n            options = {\n                data: {\n                    'application/vnd.jupyter.stderr': payload.traceback.join('\\n') ||\n                        `${payload.ename}: ${payload.evalue}`\n                }\n            };\n        }\n        return this.__rendermime.createModel(options);\n    }\n    /**\n     * Render the IExpressionResult produced by the kernel\n     */\n    _renderExpressionResult(payload) {\n        const model = this._createExpressionResultModel(payload);\n        // Select preferred mimetype for bundle\n        // FIXME: choose appropriate value for `safe`\n        const mimeType = this.__rendermime.preferredMimeType(model.data, 'any');\n        if (mimeType === undefined) {\n            console.error(\"Couldn't find mimetype\");\n            return this._renderError();\n        }\n        // Create renderer\n        const renderer = this.__rendermime.createRenderer(mimeType);\n        renderer.addClass(RENDERED_CLASS);\n        renderer.addClass(RESULT_CLASS);\n        // Render model\n        renderer.renderModel(model);\n        return renderer.node;\n    }\n    /**\n     * Render a generic error in-line\n     */\n    _renderError() {\n        const node = document.createElement('span');\n        node.classList.add(RENDERED_CLASS);\n        node.classList.add(ERROR_CLASS);\n        return node;\n    }\n    /**\n     * Render the given expression from an existing cell attachment MIME bundle.\n     * Render an in-line error if no data are available.\n     */\n    _renderExpression(name) {\n        var _a;\n        const attachment = this.model.attachments.get(name);\n        // We need an attachment!\n        if (attachment === undefined) {\n            console.error(`Couldn't find attachment ${name}`);\n            return this._renderError();\n        }\n        // Try and render the output from cell attachments\n        const payload = ((_a = attachment.data[OUTPUT_MIMETYPE]) !== null && _a !== void 0 ? _a : attachment.data[ERROR_MIMETYPE]);\n        if (payload !== undefined) {\n            return this._renderExpressionResult(payload);\n        }\n        // Couldn't find valid MIME bundle, so we need to handle that!\n        console.error(`Couldn't find valid MIME bundle for attachment ${name}`);\n        return this._renderError();\n    }\n    /**\n     * Update rendered expressions from current attachment MIME-bundles\n     */\n    renderExpressions() {\n        console.log('Rendering expressions');\n        // Loop over expressions and render them from the cell attachments\n        for (const name in this.__expressions) {\n            const node = this._renderExpression(name);\n            this._replaceRenderedExpression(name, node);\n        }\n    }\n    /**\n     * Update an expression DOM node (result or placeholder) with a new result\n     */\n    _replaceRenderedExpression(name, node) {\n        var _a;\n        const placeholder = this.__placeholders[name];\n        (_a = placeholder.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(node, placeholder);\n        this.__placeholders[name] = node;\n    }\n    /**\n     * Wait for Markdown rendering to complete.\n     * Assume that rendered container will have at least one child.\n     */\n    _waitForRender(widget, timeout) {\n        // FIXME: this is a HACK\n        return new Promise(resolve => {\n            function waitReady() {\n                const firstChild = widget.node.querySelector('.jp-RenderedMarkdown *');\n                if (firstChild !== null) {\n                    return resolve();\n                }\n                setTimeout(waitReady, timeout);\n            }\n            waitReady();\n        });\n    }\n    renderInput(widget) {\n        // FIXME: `renderInput` is called without waiting for render future to finish\n        // Therefore, this is sometimes executed before the DOM is updated.\n        super.renderInput(widget);\n        const currentContent = this.model.value.text;\n        // If the content has changed\n        if (this.__lastContent !== undefined &&\n            this.__lastContent !== currentContent) {\n            this.__doneRendering = new PromiseDelegate();\n            // Store parsed expressions\n            this._waitForRender(widget, 10).then(() => {\n                this._identifyExpressions(widget);\n                this.renderExpressions();\n                this.__doneRendering.resolve();\n            });\n            this.__lastContent = currentContent;\n        }\n    }\n    /**\n     * Parse the rendered markdown, and store placeholder and expression mappings\n     */\n    _identifyExpressions(widget) {\n        const exprInputNodes = widget.node.querySelectorAll(`input.${EXPR_CLASS}`);\n        // Store expressions & placeholders\n        this.__expressions = {};\n        this.__placeholders = {};\n        exprInputNodes.forEach((node, index) => {\n            const name = `${ATTACHMENT_PREFIX}-${index}`;\n            this.__expressions[name] = node.value;\n            this.__placeholders[name] = node;\n        });\n        console.log('Found expressions', this.__expressions, this.__placeholders);\n    }\n}\n","import { plugin } from './plugin';\nimport { INotebookTracker, NotebookActions, NotebookPanel } from '@jupyterlab/notebook';\nimport { IEditorServices } from '@jupyterlab/codeeditor';\nimport { ATTACHMENT_PREFIX, XMarkdownCell } from './cell';\nimport { loadUserExpressions } from './kernel';\nclass XMarkdownContentFactory extends NotebookPanel.ContentFactory {\n    /**\n     * Create a new markdown cell widget.\n     *\n     * #### Notes\n     * If no cell content factory is passed in with the options, the one on the\n     * notebook content factory is used.\n     */\n    createMarkdownCell(options, parent) {\n        if (!options.contentFactory) {\n            options.contentFactory = this;\n        }\n        return new XMarkdownCell(options).initializeState();\n    }\n}\n/**\n * The notebook cell factory provider.\n */\nconst factory = {\n    id: '@agoose77/jupyterlab-imarkdown:factory',\n    provides: NotebookPanel.IContentFactory,\n    requires: [IEditorServices],\n    autoStart: true,\n    activate: (app, editorServices) => {\n        console.log('Using jupyterlab-imarkdown:editor');\n        const editorFactory = editorServices.factoryService.newInlineEditor;\n        return new XMarkdownContentFactory({ editorFactory });\n    }\n};\nfunction isMarkdownCell(cell) {\n    return cell.model.type === 'markdown';\n}\nfunction removeKernelAttachments(cell) {\n    const attachments = cell.model.attachments;\n    attachments.keys\n        .filter(key => {\n        key.startsWith(ATTACHMENT_PREFIX);\n    })\n        .map(attachments.remove);\n}\n/**\n * The notebook cell executor.\n */\nconst executor = {\n    id: '@agoose77/jupyterlab-imarkdown:executor',\n    requires: [INotebookTracker],\n    autoStart: true,\n    activate: (app, tracker) => {\n        console.log('Using jupyterlab-imarkdown:executor');\n        const executed = NotebookActions.executed;\n        executed.connect((sender, value) => {\n            const { notebook, cell } = value;\n            // Find the Notebook panel\n            const panel = tracker.find((w) => {\n                return w.content === notebook;\n            });\n            // Retrieve the kernel context\n            const ctx = panel === null || panel === void 0 ? void 0 : panel.sessionContext;\n            if (ctx === undefined) {\n                return;\n            }\n            // Load the user expressions for the given cell.\n            if (!isMarkdownCell(cell)) {\n                return;\n            }\n            console.log('Markdown cell was executed, waiting for render to complete ...');\n            cell.doneRendering.then(() => {\n                console.log('Clearing results from cell attachments');\n                removeKernelAttachments(cell);\n                console.log('Loading results from kernel');\n                loadUserExpressions(cell, ctx).then(() => {\n                    console.log('Re-rendering cell!');\n                    cell.renderExpressions();\n                });\n            });\n        });\n        return;\n    }\n};\n/**\n * Export the plugins as default.\n */\nconst plugins = [factory, executor, plugin];\nexport default plugins;\n","import { ERROR_MIMETYPE, isError, OUTPUT_MIMETYPE } from './attachment';\n/**\n * Load user expressions for given XMarkdown cell from kernel.\n * Store results in cell attachments.\n */\nexport async function loadUserExpressions(cell, sessionContext) {\n    var _a;\n    const model = cell.model;\n    const cellId = { cellId: model.id };\n    // Populate request data\n    const content = {\n        code: '',\n        user_expressions: cell.expressions\n    };\n    // Perform request\n    console.log('Performing kernel request', cell.expressions);\n    const kernel = (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;\n    if (!kernel) {\n        throw new Error('Session has no kernel.');\n    }\n    const future = kernel.requestExecute(content, false, Object.assign(Object.assign({}, model.metadata.toJSON()), cellId));\n    // Set response handler\n    future.onReply = (msg) => {\n        const content = msg.content;\n        if (content.status !== 'ok') {\n            return;\n        }\n        console.log('Handling kernel response', msg);\n        // Store results as attachments\n        for (const key in content.user_expressions) {\n            const result = content.user_expressions[key];\n            // Determine MIME type to store\n            const mimeType = isError(result) ? ERROR_MIMETYPE : OUTPUT_MIMETYPE;\n            // Construct payload from kernel response\n            // We don't do any type validation here\n            const payload = {};\n            payload[mimeType] = result;\n            cell.model.attachments.set(key, payload);\n            console.log(`Saving ${key} to cell attachments`);\n        }\n    };\n    await future.done;\n}\n","import { expressionPlugin } from './tokenize';\nimport { simpleMarkdownItPlugin } from '@agoose77/jupyterlab-markup';\nconst PACKAGE_NS = '@agoose77/jupyterlab-imarkdown';\n/**\n * Captures expressions as data-attributes\n */\nexport const plugin = simpleMarkdownItPlugin(PACKAGE_NS, {\n    id: 'markdown-it-expression',\n    title: 'Create spans with stored expressions from Markdown',\n    description: 'Embed Markdown text in a data attribute in rendered spans',\n    documentationUrls: {\n        Plugin: '...'\n    },\n    plugin: async () => {\n        const defaultOptions = {\n            openDelim: '{{',\n            closeDelim: '}}'\n        };\n        return [expressionPlugin, defaultOptions];\n    }\n});\n","export const EXPR_CLASS = 'im-expr';\nexport function expressionPlugin(md, options) {\n    var _a, _b;\n    const openDelim = (_a = options === null || options === void 0 ? void 0 : options.openDelim) !== null && _a !== void 0 ? _a : '{{';\n    const closeDelim = (_b = options === null || options === void 0 ? void 0 : options.closeDelim) !== null && _b !== void 0 ? _b : '}}';\n    function tokenize(state, silent) {\n        // Check we start with the correct markers\n        let pos = state.pos;\n        // For performance, just check first character\n        if (state.src[pos] !== openDelim[0]) {\n            return false;\n        }\n        // Does the full substring match?\n        if (state.src.slice(pos, pos + openDelim.length) !== openDelim) {\n            return false;\n        }\n        pos += openDelim.length;\n        // First index _after_ {{\n        const startPos = pos;\n        // Find end marker }}\n        let stopPos = -1;\n        while (stopPos === -1) {\n            // Find first character of end marker\n            pos = state.src.indexOf(closeDelim[0], pos);\n            // Didn't find character\n            if (pos === -1) {\n                return false;\n            }\n            // If subsequent tokens don't match, just advance by one token!\n            if (state.src.slice(pos, pos + closeDelim.length) !== closeDelim) {\n                pos++;\n                continue;\n            }\n            stopPos = pos;\n            pos += closeDelim.length;\n        }\n        // Read tokens inside of the bracket\n        const expression = state.src.slice(startPos, stopPos);\n        state.pos = pos;\n        const exprToken = state.push('expr', 'input', 0);\n        exprToken.attrSet('type', 'hidden');\n        exprToken.attrSet('class', EXPR_CLASS);\n        exprToken.attrSet('value', expression);\n        return true;\n    }\n    md.inline.ruler.after('emphasis', 'expr', tokenize);\n}\n"],"names":[],"sourceRoot":""}